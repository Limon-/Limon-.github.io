<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sunshell]]></title>
  <link href="http://limon-.github.io//atom.xml" rel="self"/>
  <link href="http://limon-.github.io//"/>
  <updated>2015-01-08T10:07:39+08:00</updated>
  <id>http://limon-.github.io//</id>
  <author>
    <name><![CDATA[Limon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[爬支付宝的各种坑]]></title>
    <link href="http://limon-.github.io//blog/2015/01/07/pa-zhi-fu-bao-de-ge-chong-keng/"/>
    <updated>2015-01-07T13:57:57+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/07/pa-zhi-fu-bao-de-ge-chong-keng</id>
    <content type="html"><![CDATA[<p>爬了几天坑，在笔者崩溃之际终于集成好了，在这里分享一下经验。</p>

<p>笔者用的是<code>支付宝移动支付SDK标准版(iOS 2.1.2)</code>，申请的手机快捷支付</p>

<h2>密钥</h2>

<p>利用支付宝给的<code>openssl.exe</code>工具生成一共三种密钥，私钥、公钥，PKCS8类型的私钥</p>

<ul>
<li>公钥：放在支付宝上，去掉首尾的<code>-----BEGIN PUBLIC KEY-----``-----END PUBLIC KEY-----</code></li>
<li>PKCS8类型的私钥：如果选择在手机端签名，此私钥放在<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
<li>私钥：此私钥带有<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>，是专门给PHP用的，即在服务器端(PHP)签名，需要用到此私钥

<blockquote><p>Note：推荐服务器端签名，不过需要注意的是，PHP端用的是带<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>的私钥。</p></blockquote></li>
</ul>


<h2>集成支付宝</h2>

<p>按照文档给的流程理论上想运行Demo是挺容易的，需要注意：</p>

<ul>
<li>Demo是在本地签的名，所以Demo上填写<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
</ul>


<p>如果认为看似Demo超简单，你就错了。</p>

<h3>坑一：Undefined symbols for architecture x86_64:</h3>

<p>笔者爬过的坑，<code>ssl库</code>不支持x86_64就是64位模拟器。（若在服务器端签名不需引入ssl库）</p>

<blockquote><p>程序界公认女神@念茜给出的答案。。。</p></blockquote>

<p>也就是以下这种错误</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/alipay.png" alt="alipay error" /></p>

<p>针对这个错误，笔者尝试了各种方法，Architectures的各种设置，甚至都是一行一行对着Demo来改的，还有C++ Flage等等，最终还是不行。</p>

<p>和客服聊了一个多小时，最后客服把支付宝最老的版本和13年的版本给笔者。。。。挺好人的。。。。</p>

<h3>坑二：rsaSign()和rsaVerify()</h3>

<p>作为一个技术渣，iOS我是搞不掂了，还是搞PHP吧。。。</p>

<p>吐血的是，笔者用支付宝给的PHP版Demo，用它里面的方法<code>rsaSign()</code>签名，然后再用<code>rsaVerify()</code>验签，结果<code>rsaVerify()</code>返回的结果永远都是false，后来笔者终于准备出坑了，醒悟这个<code>rsaVerify()</code>应该不是验证这签名的。</p>

<p>后来百度了解了点皮毛：</p>

<p>RSA非对称密钥</p>

<p>① 假设A、B机器进行通信，已A机器为主；</p>

<p>② A首先需要用自己的私钥为发送请求数据签名，并将公钥一同发送给B；</p>

<p>③ B收到数据后，需要用A发送的公钥进行验证，已确保收到的数据是未经篡改的；</p>

<p>④ B验签通过后，处理逻辑，并把处理结果返回，返回数据需要用A发送的公钥进行加密（公钥加密后，只能用配对的私钥解密）；</p>

<p>⑤ A收到B返回的数据，使用私钥解密，至此，一次数据交互完成。</p>

<blockquote><p><code>rsaVerify</code>笔者猜测是验证支付宝的回调的。换句话说，签名直接就用<code>rsaSign()</code>就好了，就以下这几行代码</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>include('alipay_rsa.function.php');
</span><span class='line'>
</span><span class='line'>$data = $_POST['data'];
</span><span class='line'>$sign = rsaSign($data,'../key/rsa_private_key.pem');
</span><span class='line'>
</span><span class='line'>$arr = array(
</span><span class='line'>  'sign' =&gt; $sign
</span><span class='line'>);
</span><span class='line'>
</span><span class='line'>echo json_encode($arr);
</span><span class='line'>?&gt;</span></code></pre></td></tr></table></div></figure>


<p>以为这样就爬完了？</p>

<h3>坑三：urlEncoded</h3>

<p>想着服务器直接返回<code>sign</code>直接再拼接一下就提交给支付宝，结果又掉坑里。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic).....
</code></pre>

<p>又跑去和客服聊天，笔者问客服：服务器返回的<code>sign</code>应该还需要<code>urlEncoded</code>对吧，客服回我说：不用啊，服务器已经弄了啊。</p>

<pre><code>/**
* RSA签名
* @param $data 待签名数据
* @param $private_key_path 商户私钥文件路径
* return 签名结果
*/
function rsaSign($data, $private_key_path) {
    $priKey = file_get_contents($private_key_path);
    $res = openssl_pkey_get_private($priKey);
    openssl_sign($data, $sign, $res);
    openssl_free_key($res);
    //base64编码
    $sign = base64_encode($sign);
    return $sign;
}
</code></pre>

<p>客服说<code>base64_encode($sign)</code>完就可以了不需要<code>urlEncoded</code>。笔者果断还是不相信客服。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

// 深坑啊......    
signedString = [self urlEncodedString:signedString];

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic)....
</code></pre>

<p>需要在<code>RSADataSigner.m</code>中抽离<code>-urlEncodedString</code>方法出来。。。坑啊，明明都不需要手机端签名了，当然不会去看手机端签名的具体流程啦。又没看到哪里说明服务器端返回的<code>sign</code>需要<code>urlEncoded</code>，连客服都不知道需要<code>urlEncoded</code>&hellip;..</p>

<h3>心塞，不说了&hellip;&hellip;.</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa]]></title>
    <link href="http://limon-.github.io//blog/2014/12/28/reactivecocoa/"/>
    <updated>2014-12-28T17:44:25+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/28/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<h2>RACSignal</h2>

<h3>订阅RACSignal</h3>

<p>1.RACSignal (Subscription)
RACSignal (Subscription)类别可以看到所有的订阅事件的方法，每个方法都会将类型为(void (^)(id x))的block作为参数，当事件发生时block中的代码会执行，例如-subscribeNext:方法会传入一个block作为参数，当Signal的next事件发出后，block会接收到事件并执行。</p>

<p>2.UIKit Category
RAC为UIKit添加了很多类别来让我们可以订阅UI组件的事件，比如UITextField (RACSignalSupport)中的rac_textSignal会在文本域内容变化时发出next事件。
事件包含的内容可以是类型，只要是对象就行，如果是一些数字，布尔值等字面量，可以用@()语法装箱成NSNumber。</p>

<h3>操纵Signal</h3>

<h5>1.RACStream (Operations)</h5>

<p><code>-filter</code>:uses a block to test each value. Returns a new stream with only those values that passed.</p>

<pre><code>- (instancetype)filter:(BOOL (^)(id value))block;
    RACSequence *numbers = [@"1 2 3 4 5 6 7 8 9" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: 2 4 6 8
RACSequence *filtered = [numbers filter:^ BOOL (NSString *value) {
    return (value.intValue % 2) == 0;
}];
</code></pre>

<p><code>-map</code>:Maps block across in the receiver , and transform the values. Returns a new stream with the mapped values.</p>

<pre><code>- (instancetype)map:(id (^)(id value))block;
    RACSequence *letters = [@"A B C D E F G H I" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: AA BB CC DD EE FF GG HH II
RACSequence *mapped = [letters map:^(NSString *value) {
    return [value stringByAppendingString:value];
}];
</code></pre>

<p><code>-flattenMap</code>:Maps block across the values in the receiver and flattens the result. It is used to signal of signal.简单理解为：取出内部的Signal.</p>

<pre><code>[[[self.signInButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
        map:^id(id x) {
            return [self signInSignal]; // 此signal内含一个BOOL signal
    }]
    subscribeNext:^(id x) {
        NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>打印出来的不是BOOL，<code>-subscribeNex</code>t: will execute the block whenever the signal sends a value. 但这value不包括 signal of signals：an outer signal that contains an inner signal.</p>

<pre><code>2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result: 
                        &lt;RACDynamicSignal: 0xa068a00&gt; name:+createSignal:
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[[self.signInButton
</span><span class='line'>   rac_signalForControlEvents:UIControlEventTouchUpInside]
</span><span class='line'>   flattenMap:^id(id x) { // subscribe to the inner signal within the outer signal’s
</span><span class='line'>     return [self signInSignal];
</span><span class='line'>   }]
</span><span class='line'>   // Output: Sign in result: 0
</span><span class='line'>   subscribeNext:^(id x) {
</span><span class='line'>     NSLog(@"Sign in result: %@", x);
</span><span class='line'>   }];</span></code></pre></td></tr></table></div></figure>


<h4>2.RACSignal (Operations)</h4>

<h2>RACObserve</h2>

<pre><code>// When self.username changes, logs the new name to the console.
//
// RACObserve(self, username) creates a new RACSignal that sends the current
// value of self.username, then the new value whenever it changes.
// -subscribeNext: will execute the block whenever the signal sends a value.
[RACObserve(self, username) subscribeNext:^(NSString *newName) {
    NSLog(@"%@", newName);
}];
</code></pre>

<h4>过滤signal</h4>

<pre><code>// Only logs names that starts with "j".
//
// -filter returns a new RACSignal that only sends a new value when its block
// returns YES.
[[RACObserve(self, username)
    filter:^(NSString *newName) {
        return [newName hasPrefix:@"j"];
    }]
    subscribeNext:^(NSString *newName) {
        NSLog(@"%@", newName);
}];
</code></pre>

<h2>Chip</h2>

<p><code>distinctUntilChanged</code>：Returns a stream of values for which -isEqual: returns NO when compared to the previous value.
用来确保signal只会发送不同的值,比较数值流中当前值和上一个值，如果不同，就返回当前值，简单理解,它将这一次的值与上一次做比较，当相同时（也包括- isEqual:）被忽略掉。</p>

<pre><code>RACSignal *validSearchSignal =
[[RACObserve(self, searchText)
  map:^id(NSString *text) {
     return @(text.length &gt; 3);
  }]
  distinctUntilChanged]; // ensure this signal only emits values when the state changes.

[validSearchSignal subscribeNext:^(id x) {
    NSLog(@"search text is valid %@", x);
}];

self.executeSearch =
[[RACCommand alloc] initWithEnabled:validSearchSignal // validSearchSignal决定button能不能点击
  signalBlock:^RACSignal *(id input) {
    return  [self executeSearchSignal];
  }];
</code></pre>

<p>例子二：比如UI上一个Label绑定了一个值，根据值更新显示的内容:</p>

<pre><code>RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];
self.user.username = @"sunnyxx"; // 1st
self.user.username = @"sunnyxx"; // 2nd
self.user.username = @"sunnyxx"; // 3rd 
</code></pre>

<p>所以，对于相同值可以忽略的情况，果断加上它吧。</p>

<p><code>-takeUntilBlock</code>：对于每个next值，运行block，当block返回YES时停止取值，如：</p>

<pre><code>[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) {
    return [value isEqualToString:@"stop"];
}] subscribeNext:^(NSString *value) {
    NSLog(@"current value is not `stop`: %@", value);
}];
</code></pre>

<blockquote><p>Note：停止取值的意思是，输入stop之后，无论输入什么都不会再取值，即输入stop之后，不会再有任何输出。
还有一个例子：</p></blockquote>

<pre><code>- (RACSignal*) rac_RequestStateSignal
{
    return [[RACObserve(self, state)
        takeUntilBlock:^ BOOL (NSNumber *state){
            return [state intValue] == iRequestStateComplete;
        }]
        flattenMap:^(NSNumber *state){
            if ([state intValue] == iRequestStateErrored)
            { 
                // Create a meaningful NSError here if you can.
                return [RACSignal error:nil];
            }
            else
            { 
                return [RACSignal return:state];
            }
        }];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodeChip]]></title>
    <link href="http://limon-.github.io//blog/2014/12/28/codechip/"/>
    <updated>2014-12-28T00:10:03+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/28/codechip</id>
    <content type="html"><![CDATA[<h1>CodeChip</h1>

<h3>改变UITextfiedl的placeholder的颜色</h3>

<pre><code>[searchField setValue:[UIColor whiteColor] forKeyPath:@"_placeholderLabel.textColor"];
</code></pre>

<h3>统计数组中重复对象的个数</h3>

<pre><code>NSArray *array = @[@1, @2, @2, @1];
NSCountedSet *set = [[NSCountedSet alloc]initWithArray:array];

[set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
    NSLog(@"%@ =&gt; %lu", obj, (unsigned long)[set countForObject:obj]);
}];
</code></pre>

<blockquote><p>Each distinct object inserted into an NSCountedSet object has a counter associated with it.</p></blockquote>

<p>即，NSCountedSet内的每个不同的对象都有一个与之相关的计数器。
也就是说如果遇到重复对象的加入，这个对象的计数器就会+1。所以这个类有个名叫<code>- (NSUInteger)countForObject:(id)object;</code>的方法来统计重复对象的个数。</p>

<h3>跳转到系统设置界面(只适用用iOS 8)</h3>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
</code></pre>

<h3>跳转到APP Store（iOS 7之后）</h3>

<p>跳转到产品详情界面</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"itms-apps://itunes.apple.com/app/idxxxxxx"]];
</code></pre>

<p>跳转到产品评论界面</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=xxxxxx&amp;pageNumber=0&amp;sortOrdering=2&amp;type=Purple+Software&amp;mt=8"]];
</code></pre>

<p>xxxxx是的Apple ID</p>

<h3>隐藏键盘(点击屏幕任意位置)</h3>

<p>在VC中添加</p>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    [super touchesBegan:touches withEvent:event];
    [self.view endEditing:YES];
}   
</code></pre>

<h3>解决64位上%d和%u警告</h3>

<pre><code>#if __LP64__
#define NSI "ld"
#define NSU "lu"
#else
#define NSI "d"
#define NSU "u"
#endif 
</code></pre>

<p>使用</p>

<pre><code>NSInteger row = 2;
NSLog(@"i=%"NSI, row);
</code></pre>

<h3>判断一个view是否是另一个view的子视图</h3>

<pre><code>- (BOOL)isDescendantOfView:(UIView *)view;
</code></pre>

<h3>获取点击处的cell的indexPath</h3>

<pre><code>NSIndexPath *path = [_collectionView indexPathForItemAtPoint:[button convertPoint:CGPointZero toView:self.collectionView]];
</code></pre>

<h3>度数转换为弧度</h3>

<pre><code>#define tranformDegree(x) ((x)*(M_PI)/(180.0f))
</code></pre>

<p>弧度 = 角度* π / 180</p>

<h3>判断string是中文</h3>

<pre><code>unichar c = [searchString characterAtIndex:0];
// 汉字
if (c &gt;= 0x4E00 &amp;&amp; c &lt;= 0x9FFF){
}
</code></pre>

<h3>将数组切割成字符串</h3>

<pre><code>NSArray *array=[[NSArray alloc]initWithObjects:@"苹果",@"香蕉",@"草莓", @"菠萝", nil];
NSString *newString=[array componentsJoinedByString:@","];    
NSLog(@"%@", newString);
</code></pre>

<h3>将字符串切割成数组</h3>

<pre><code>NSString *a = [[NSString alloc] initWithString : @"冬瓜，西瓜，火龙果，大头，小狗" ];
NSArray *b = [a componentsSeparatedByString:@"，"];
</code></pre>

<h2>TableView</h2>

<h3>在包含UITableView视图中添加单击手势</h3>

<p>如果在包含UITableView视图中添加单击手势，这个单击手势会屏蔽掉UITableView的<code>didSelectRowAtIndexPath</code>
在单击点位于UITableView内的时候取消响应</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
    CGPoint point = [gestureRecognizer locationInView:self];
    if(CGRectContainsPoint(menuTableView.frame, point)){
        return NO;
    }
    return YES;
}
</code></pre>

<p>简单点的就将单击手势的cancelsTouchesInView设置为NO即可</p>

<pre><code>singleTap.cancelsTouchesInView = NO;
</code></pre>

<blockquote><p>默认为YES，若NO，Gesture Recognizers和hit-test view同时响应触摸序列</p></blockquote>

<h3>修改cell右边图标颜色</h3>

<pre><code>mytableView.tintColor = [UIColor greenColor];
</code></pre>

<h3>cell删除动画</h3>

<pre><code>//删除一个cell时，设定动画模式
[tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];
</code></pre>

<h2>杂</h2>

<p>计算字符串宽度</p>

<pre><code>CGFloat priceLabelW = [priceStr sizeWithAttributes:@{NSFontAttributeName:searchResultsNameFont}].width;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#01-字面量语法]]></title>
    <link href="http://limon-.github.io//blog/2014/12/26/number-01-zi-mian-liang-yu-fa/"/>
    <updated>2014-12-26T12:40:19+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/26/number-01-zi-mian-liang-yu-fa</id>
    <content type="html"><![CDATA[<h2>字面量数值</h2>

<p>普通创建：</p>

<pre><code>NSNumber *num = [NSNumber numberWithInt:1];
</code></pre>

<p>字面量创建</p>

<pre><code>NSNumber *nub = @1;

int a = 5;
float b = 5.32f;
NSNumber *num = @(a * b);
</code></pre>

<h2>字面量数组</h2>

<p>普通创建</p>

<pre><code>NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",@"Apple",nil];
[fruits objectAtIndex:1]; // Apple
</code></pre>

<p>字面量创建</p>

<pre><code>NSArray *fruits = @[@"Lemon",@"Apple"];
fruits[1]; // Apple
</code></pre>

<p><code>fruits[1]</code>这称为取下标操作(subscripting)</p>

<h2>nil</h2>

<p>字面量创建数组，若数组元素对象中有nil，会抛出异常。因为字面量语法实际上是一种语法糖(syntactic sugar)，其效果等于是先创建了一个数组，然后把方括号内的所有对象都加到这个数组。</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = @[@"Lemon",nilObject,@"Apple"]; // 崩了
</code></pre>

<p>如果不用字面量创建，用<code>NSArray arrayWithObjects:</code>则不会抛出异常，只会提前结束。如下例子，遇到nil结束，fruits只有一个元素</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",nilObject,@"Apple",nil];
</code></pre>

<blockquote><p>微妙的差别表明，使用字面量语法更安全。向数组插入nil通常说明程序有错，而通过异常可以更快地发现这个错误。</p></blockquote>

<h2>字面量字典</h2>

<p>值 -> 键：普通创建</p>

<pre><code>NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:@"Tom",@"name",[NSNumber numberWithInt:18],@"age", nil];
[personData objectForKey:@"name"]; // Tom
</code></pre>

<p>键 -> 值：字面量语法创建</p>

<pre><code>NSDictionary *personData = @{@"name": @"Tom",@"age":@18};
personData[@"age"]; // 18
</code></pre>

<h2>可变数组和字典</h2>

<p>如果数组与字典对象是可变的(mutable)，也可以通过下标修改可变数组或字典的值</p>

<pre><code>mutableArray[1] = @"dog";
mutableDictionary[@"name"] = @"Mary";
</code></pre>

<p>普通做法：</p>

<pre><code>[mutableArray replaceObjectAtIndex:1 withObject:@"dog"];
[mutableDic setObject:@"Mary" forKey:@"name"];
</code></pre>

<h2>局限</h2>

<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable),若想可变版本的对象，则需要赋值一份</p>

<pre><code>NSMutableDictionary *mutableDic = [@{@"name": @"Tom",@"age":@18} mutableCopy];
</code></pre>

<h2>要点</h2>

<ul>
<li>应该使用字面量语法创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，更加简明扼要。</li>
<li>应该通过下标来访问数组和字典</li>
<li>用字面量语法创建数组或字典时，若值中有nil，会抛出异常。</li>
</ul>


<h2>番外</h2>

<p>JSON格式，一对 <code>{ }</code> 代表一个字典，一对<code>[]</code>代表一个数组</p>

<pre><code>{
    "result": 1,

    "school_list": [
        {
            "id": "5",
            "school_name": "清华大学"             
        },
        {
            "id": "6",
            "school_name": "北京邮电大学"
        }
    ],

    "school_near": "北京交通大学"
}
</code></pre>

<p>从JSON<strong>字典</strong>中通过键<code>school_list</code>取出数组对象</p>

<pre><code>NSArray *arr = json[@"school_list"];
NSArray *arr = [json objectForKey:@"school_list"];
</code></pre>

<p>arr数组的元素是一个个字典，遍历数组得到字典内的学校名</p>

<pre><code>for( int i=0; i&lt;arr.count; i++){
        NSString *schoolName = arr[i][@"school_name"];
        NSString *schoolName = [[arr objectAtIndex:i] objectForKey:@"school_name"];
    }
</code></pre>

<p>其实arr数组就是PHP内的二维数组，只不过在OS中，</p>

<ul>
<li>数组 - 下标为数字（PHP中的索引数组）</li>
<li>字典 - 下标为字符串（PHP中的关联数组）</li>
</ul>


<p>上面例子中二维数组arr的遍历，通过数字下标遍历二维数组中的所有元素，然后通过字符串下标取出学校名。</p>

<blockquote><p>下标也称为键</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa的三种基本的模式]]></title>
    <link href="http://limon-.github.io//blog/2014/12/26/reactivecocoa/"/>
    <updated>2014-12-26T09:35:03+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/26/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<hr />

<h3>三种基本的模式</h3>

<p>在ReactiveCocoa中有三种基本的模式：责任链、分割和组合模式（chaining, splitting, and combining）。</p>

<h4>一、 Chaining模式</h4>

<p>Chaining，将一个已有的signal转换为一个新的signal。常用的操作是创建一个新的signal，再对它使用filter:、map:或startWith:等方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.textField.text) = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}]; 
</span></code></pre></td></tr></table></div></figure>


<p>我们将textFiled的text属性绑定为三个串连的signals的结果。首先，我们创建一个间隔信号，这个信号每隔一秒钟就发送当前时间。间隔信号在没有启动的时候是不会有值的，所以我们使用startWith:启动起来。最后，使用map:将signal的NSDate值转换为一个NSString字符串，这个字符串将会被赋值到textField的text属性上。
<img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/chaining.png" alt="Chaining" /></p>

<p> Chaining是最常用的操作，而且它通常不使用局部变量，而是像上面那样串连起来操作。下面的代码与上面的代码是等同的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *intervalSignal = [RACSignal interval:1];  
</span><span class='line'>RACSignal *startedIntervalSignal = [intervalSignal startWith:[NSDate date]];  
</span><span class='line'>RACSignal *mappedIntervalSignal = [startedIntervalSignal map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.textField.text) = mappedIntervalSignal;  </span></code></pre></td></tr></table></div></figure>


<h4>二、Splitting模式</h4>

<p>Splitting与chaining比较类似，也是将signal转换为其它的sginal，不同之处在于，Splitting会重复使用signal。Splitting看起来要复杂些，其实也就是一个signal使用多次。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *dateComponentsSignal = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>    return dateComponents;  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.minuteTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.minute];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.secondTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.second];  
</span><span class='line'>}];  </span></code></pre></td></tr></table></div></figure>


<p>在上面这个例子中，创建了一个signal，即局部变量：dateComponentsSignal。接着再用dateComponentsSignal创建两个新的signal，并将它们分别与两个textfield的text属性进行绑定。</p>

<blockquote><p>Note: 把dateComponentsSignal看作一个局部变量，就像,int a = 9; 然后多次使用a来计算。</p></blockquote>

<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/Splitting.png" alt="Splitting" /></p>

<h4>三、Combining模式</h4>

<p>combining就是将几个signal结合起来创建出一个新的signal。比如“登录”按钮，只有在“用户名”与“密码”输入框中的文本长度都超过6时才能被点击，否则处于不可用的状态。那么我们可以为“登录”按钮的enabled状态创建一个signal，这个signal则是由“用户名”与“密码”框它们两个自己的signal组合起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.submitButton.enabled) = [RACSignal combineLatest:@[self.usernameField.rac_textSignal, self.passwordField.rac_textSignal] reduce:^id(NSString *userName, NSString *password) {  
</span><span class='line'>    return @(userName.length &gt;= 6 && password.length &gt;= 6);  
</span><span class='line'>}]; </span></code></pre></td></tr></table></div></figure>


<p>在这里，我们将“登录”按钮的enable状态绑定到使用combineLatest:reduce:方法创建的signal上。这个方法的第二个参数是一个block，这个block的参数是combineLatest中的参数的<strong>最新值</strong>的组合。我们将两个文本框的text signal一起传到combineLatest，在reduce的block中，该block也就会接收到两个NSString的参数，这个block的工作就是将两个参数值组合起来生成一个值，然后返回。该方法的说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// +combineLatest:reduce: takes an array of signals, executes the block with the
</span><span class='line'>// latest value from each signal whenever any of them changes, and returns a new
</span><span class='line'>// RACSignal that sends the return value of that block as values.</span></code></pre></td></tr></table></div></figure>


<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/combining.png" alt="Combining" /></p>

<p>Combining常用于两种情况：</p>

<ol>
<li>需要同时满足多种条件。</li>
<li>在多个signal中进行选择。</li>
</ol>


<h2>优秀文章</h2>

<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/">Getting Started with ReactiveCocoa</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转Mantle]]></title>
    <link href="http://limon-.github.io//blog/2014/12/23/mantlede-shi-yong/"/>
    <updated>2014-12-23T10:05:15+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/23/mantlede-shi-yong</id>
    <content type="html"><![CDATA[<h2>MTLModel</h2>

<p>MTLModel provides an easy way to map NSDictionary objects to Objective-C classes and vice-versa.</p>

<p>假设返回的JSON为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> {
</span><span class='line'>  "uid": 1,
</span><span class='line'>  "title": "Found a bug",
</span><span class='line'>  "url": "https://api.github.com/repos/octocat/Hello-World/issues/1347",
</span><span class='line'>  "number": 1347,
</span><span class='line'>  "state": "open",
</span><span class='line'>  "user": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1
</span><span class='line'>  },
</span><span class='line'>  "assignee": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1,
</span><span class='line'>    "type": "User"
</span><span class='line'>  }
</span><span class='line'>  "created_at": "2011-04-22T13:33:48Z",
</span><span class='line'>  "awesome": true  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>继承<code>MTLModel</code>遵守<code>&lt;MTLJSONSerializing&gt;</code>协议</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Mantle.h&gt;
</span><span class='line'>
</span><span class='line'>typedef enum : NSUInteger {
</span><span class='line'>    GHIssueStateOpen,
</span><span class='line'>    GHIssueStateClosed
</span><span class='line'>} GHIssueState;
</span><span class='line'>
</span><span class='line'>@interface GHIssue : MTLModel&lt;MTLJSONSerializing&gt;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *uid;
</span><span class='line'>@property (nonatomic, copy, readonly) NSURL *URL;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *number;
</span><span class='line'>@property (nonatomic, assign, readonly) GHIssueState state;
</span><span class='line'>@property (nonatomic, copy, readonly) NSString *reporterLogin;
</span><span class='line'>@property (nonatomic, copy, readonly) NSDate *updatedAt;
</span><span class='line'>@property (nonatomic, strong, readonly) GHUser *assignee;
</span><span class='line'>@property(nonatomic, getter=isAwesome) BOOL awesome;
</span><span class='line'>@property (nonatomic, copy) NSString *title;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p><code>&lt;MTLJSONSerializing&gt;</code>协议告诉Mantle序列化该对象如何从JSON映射到Objective-C的属性。</p>

<h3>NSValueTransformer</h3>

<p>在.m文件，实现<code>&lt;MTLJSONSerializing&gt;</code>的协议<code>@required</code>的方法<code>+ (NSDictionary *)JSONKeyPathsByPropertyKey</code>
它指明了如何把json的keypath和Model的属性对应起来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSDictionary *)JSONKeyPathsByPropertyKey {
</span><span class='line'>  // properties defined in header  :  key in JSON Dictionary，本地字段在前，服务端字段在后
</span><span class='line'>    return @{
</span><span class='line'>        @"URL": @"url",
</span><span class='line'>        @"HTMLURL": @"html_url",
</span><span class='line'>        @"reporterLogin": @"user.login",
</span><span class='line'>        @"assignee": @"assignee",
</span><span class='line'>        @"updatedAt": @"updated_at"
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为如果属性名和JSON的键名一致时，可以省略不写映射，例如title</p>

<p>以上分了几种情况：
Mantle使用主要看属性property中的类型，主要分几种：</p>

<ol>
<li>NSNumber、NSString&hellip;.</li>
<li>NSArray</li>
<li>NSURL</li>
<li>NSDate</li>
<li>枚举</li>
<li>模型</li>
<li>BOOL</li>
</ol>


<p>先介绍一个方法：<code>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Specifies how to convert a JSON value to the given property key. If
</span><span class='line'>// reversible, the transformer will also be used to convert the property value
</span><span class='line'>// back to JSON.
</span><span class='line'>//
</span><span class='line'>// If the receiver implements a `+&lt;key&gt;JSONTransformer` method, MTLJSONAdapter
</span><span class='line'>// will use the result of that method instead.
</span><span class='line'>//
</span><span class='line'>// Returns a value transformer, or nil if no transformation should be performed.
</span><span class='line'>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;
</span></code></pre></td></tr></table></div></figure>


<p>以下方法的命名都要遵从：<code>SEL selector = MTLSelectorWithKeyPattern(key, "JSONTransformer");</code></p>

<p>1、一般像tittle，<code>@"title": @"title"</code>不用写这行也自动转化。我个人认为从服务器返回的所有数据都是字符串类型。所有理论上，uid还要用<code>NSValueTransformer</code>转化，如下：</p>

<pre><code>+ (NSValueTransformer *)uidJSONTransformer{
    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^id(NSString *string) {
    return @([string integerValue]);
} reverseBlock:^id(NSNumber *number) {
    return [number stringValue];
}];
</code></pre>

<p>}</p>

<p>但是，如果你的uid属性类型定义为NSNumber，还是不需用上面的方法，应该是Mantle自己处理了。</p>

<blockquote><p>如果你定义的uid类型为NSUInteger，还是需要uidJSONTransformer</p></blockquote>

<p>还有一种情况是<code>@"reporterLogin": @"user.login"</code>
   login是在JSON内层的元素，需要用下面这个方法</p>

<pre><code class="```">   + (NSValueTransformer *)reporterLoginJSONTransformer {
        return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSArray *values) {
            return [values firstObject];
        } reverseBlock:^(NSString *str) {
            return @[str];
        }];
    }
</code></pre>

<p>2、NSArray装模型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  name: "Bob",
</span><span class='line'>  cars: [
</span><span class='line'>    { make: "ford", year: "1972" },
</span><span class='line'>    { make: "mazda", year: "2000" }
</span><span class='line'>  ],
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface CarModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *make;
</span><span class='line'>@property (nonatomic, strong) NSString *year;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@interface PersonModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *name;
</span><span class='line'>@property (nonatomic, strong) NSArray *cars; // NSArra元素是Car模型
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)carsJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CarModel.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3、NSURL</p>

<pre><code>+ (NSValueTransformer *)URLJSONTransformer {
    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
}           
</code></pre>

<p>4、NSDate</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>+ (NSDateFormatter *)dateFormatter {
</span><span class='line'>    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
</span><span class='line'>    dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
</span><span class='line'>    dateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss'Z'";
</span><span class='line'>    return dateFormatter;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (NSValueTransformer *)updatedAtJSONTransformer { // 把"updated_at": "2011-04-22T13:33:48Z"传给ForwardBlock
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [self.dateFormatter dateFromString:str]; // 把dateFormatter再传给reverseBlock
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [self.dateFormatter stringFromDate:date];
</span><span class='line'>    }]
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果JSON的数据格式是Unix时间戳，&#8221;date&#8221;: 1418202490,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)dateJSONTransformer {
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [NSDate dateWithTimeIntervalSince1970:str.floatValue];
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [NSString stringWithFormat:@"%f",[date timeIntervalSince1970]];
</span><span class='line'>    }];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>5、枚举</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)stateJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{
</span><span class='line'>        @"open": @(GHIssueStateOpen),
</span><span class='line'>        @"closed": @(GHIssueStateClosed)
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>6、模型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)assigneeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONDictionaryTransformerWithModelClass:GHUser.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>7、 BOOL</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)awesomeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>空对象处理</h2>

<p>在模型.m文件添加<code>-setNilValueForKey</code>，Mantle是基于KVC给property赋值的，KVC提供了<code>-setNilValueForKey</code>方法，让我们为nil指定一个合理的替代值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface MTLModel (KTVNullableScalar)
</span><span class='line'>@end
</span><span class='line'>@implementation MTLModel (KTVNullableScalar)
</span><span class='line'>- (void)setNilValueForKey:(NSString *)key {
</span><span class='line'>    [self setValue:@0 forKey:key];  // For NSInteger/CGFloat/BOOL
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>Create model objects from JSON</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from JSON data
</span><span class='line'>NSData JSONData = ... // the JSON response from the API
</span><span class='line'>NSError *error = nil;
</span><span class='line'>NSDictionary *JSONDict = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:&error];
</span><span class='line'>
</span><span class='line'>// create model object from NSDictionary using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = [MTLJSONAdapter modelOfClass:CATProfile.class fromJSONDictionary:JSONDict error:NULL];</span></code></pre></td></tr></table></div></figure>


<h2>Create JSON from model objects</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from model class using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = ...
</span><span class='line'>NSDictionary *profileDict = [MTLJSONAdapter JSONDictionaryFromModel:profile];
</span><span class='line'>NSError *error = nil;
</span><span class='line'>// convert NSDictionary to JSON data
</span><span class='line'>NSData *JSONData = [NSJSONSerialization dataWithJSONObject:profileDict options:0 error:&error];</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Note：如果不想JSONData含有模型的某个属性，可以在模型JSONKeyPathsByPropertyKey方法中
    return @{ @&ldquo;Name&rdquo;: NSNull.null };</p></blockquote>

<h2>Serialize 序列化</h2>

<p>待续&hellip;</p>

<h2>优秀文章</h2>

<p><a href="http://spin.atomicobject.com/2014/06/23/ios-models-mantle/">Simplify iOS Models With Mantle – An Intro</a></p>

<p><a href="http://www.objc.at/mantle">mantle</a></p>

<p><a href="http://www.cnblogs.com/ipinka/p/4041835.html">iOS的Mantle实战</a></p>

<p><a href="http://ke.gitcafe.io/2014/10/13/Why-Changba-iOS-choose-Mantle/">为什么唱吧iOS 6.0选择了Mantle</a></p>
]]></content>
  </entry>
  
</feed>
