<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Limon's Blog]]></title>
  <link href="http://limon-.github.io//atom.xml" rel="self"/>
  <link href="http://limon-.github.io//"/>
  <updated>2015-01-26T13:36:58+08:00</updated>
  <id>http://limon-.github.io//</id>
  <author>
    <name><![CDATA[Limon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Cheat Sheet]]></title>
    <link href="http://limon-.github.io//blog/2015/01/26/swift-cheat-sheet/"/>
    <updated>2015-01-26T13:36:08+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/26/swift-cheat-sheet</id>
    <content type="html"><![CDATA[<h2>Tuples 元组</h2>

<p>元组，将多个不同的值集合成一个数据</p>

<ul>
<li>可有任意多个值</li>
<li>不同的值可有是不同类型</li>
</ul>


<h3>元组的定义</h3>

<pre><code>// 方式一
let loginResult = (true,"Limon","男")
let( isLogin, nickName, gender) = loginResult

// output: Limon
nickName 
loginResult.1

// 方式二
let loginResult = (isLogin:true, nickName:"Limon", gender:"男")

// 总结
let loginResult:(BOOL, String) = (isLogin:true, nickName:"Limon", gender:"男")
</code></pre>

<h3>忽略部分数值</h3>

<pre><code>let loginResult = (true,"Limon")
let (isLoginSuccess, _ ) = loginResult
if isLoginSuccess{
    println("登录成功")
}
</code></pre>

<h2>Optional 可选型</h2>

<p>Optional，或者是一个值，或者是没有值，没有值时为<code>nil</code></p>

<blockquote><p>在Swift中，纯量类型也可为<code>nil</code></p></blockquote>

<h3>Optional的定义</h3>

<pre><code>var inOptionalVariable:Int?  // 默认为nil

let nickName:String? = "Limon"
nickName   // output：{Some "Limon"}
nickName!  // output："Limon"  ----- 解包

let nickName:String! = "Limon" 
nickName   // output："Limon"
</code></pre>

<h2>nil聚合运算符</h2>

<pre><code>a ?? b  -&gt;  a != nil ? a! :b
</code></pre>

<p>a必须是optional，b的类型与a!必须一致</p>

<h3>运用：</h3>

<pre><code>var nickName:String?
nickName = "Limon"

//let outputName:String = nickName != nil ? nickName! : "Guest"
let outputName:String = nickName ?? "Guest" // nickName不为空,则输出nickName的解包，否则输出Guest

println("Hello, " + outputName) 
</code></pre>

<h2>Range Operator 区间运算符</h2>

<p>Closed Range Opertor</p>

<p>闭区间<code>[a,b]</code> -> <code>a...b</code></p>

<p>Half-Closed Range Operator</p>

<p>前闭后开区间<code>[a,b)</code> -> <code>a..&lt;b</code></p>

<blockquote><p><code>..&lt;</code>更新与beta3</p></blockquote>

<h3>运用</h3>

<pre><code>for index in 1...10
{
    index
}

let infoArray = ["Limon", "18", "程序猿"]
for i in 0..&lt; infoArray.count
{
    infoArray[i]
}
</code></pre>

<h2>String和Character</h2>

<h3>基本运用</h3>

<pre><code>var str0 = String()  // 空字符串 var str0: String  也可以
var str = "Hello, playground"

// 遍历
for c in str
{
    println(c)
}

// 拼接
var ch:Character = "!"
str.append(ch)
str +=  "!!"

// 计算字符串长度
countElements(str)

// 字符串比较
let strA = "abc"
let strB = "abc"
let strC = "abd"
let strD = "abcd"

strA == strB
strA &lt; strC
strD &lt; strC // true，字典序

strA.hasPrefix("a")
strA.hasSuffix("c")
</code></pre>

<h3>Foundation类库的String方法</h3>

<pre><code>// 导入Foundation
import Foundation

var str = "Hello,playground"
// 首字母大写
str.capitalizedString
// 全部大写
str.uppercaseString
// 小写
str.lowercaseString


// 字符串截取 trim
var str2 = "   Hello!!!!   "
// 去除空格
str2.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())
// 去除指定字符串，output：Hello
str2.stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: " !"))

// 字符串拆分 split
var str3 = "welcome to playground"
str3.componentsSeparatedByString(" ")

// 根据指定字符串拆分
str3 = "welcome to playground!Step-by-Step learn"
str3.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString: " !-"))

// 合并字符串 join
var str4 = "-"
str4.join(["1","2","3"])
</code></pre>

<h3>String.Index和Range</h3>

<pre><code>// 搜索指定字符串
var str = "welcome to playground! Step-by-Step learn"
// 默认向前搜索
str.rangeOfString("Step")
// 从后向前搜索
str.rangeOfString("Step", options: NSStringCompareOptions.BackwardsSearch)
// 忽略大小写
str.rangeOfString("step", options: NSStringCompareOptions.CaseInsensitiveSearch)
</code></pre>

<h3>Range结构体</h3>

<pre><code>// "&lt; &gt;"内为数据的类型
let startIndex:String.Index = str.startIndex
let endIndex = advance(str.startIndex, 10)  // 此endIndex的类型是 String.Index
let searchRange = Range&lt;String.Index&gt;(start: startIndex, end: endIndex)

// 在searchRange中搜索
str.rangeOfString("Step", options: NSStringCompareOptions.CaseInsensitiveSearch, range: searchRange)

// 字符串截取 substring
var toIndex = advance(str.startIndex, 3)
str.substringToIndex(toIndex)  // output：wel
str.substringWithRange(...Range&lt;String.Index&gt;...)
</code></pre>

<h3>数组</h3>

<p><code>var array = ["A","B","C"]</code></p>

<ul>
<li>不同于OC，Swift中，数组只能存同一种类型的数据，不能存字符串，又存整数</li>
<li>所存的数据不一定是一个类的对象，可以是基础数据类型（在OC中，想存int，只能转化为NSNumber）</li>
</ul>


<blockquote><p>第一点不知道对不对，<code>var array = ["A",2,"C"]</code>这样不报错，不过类型变成了<code>NSObject</code></p></blockquote>

<h4>数组的定义</h4>

<pre><code>var array = ["A","B","C"]
var array2:[String] = ["A","B","C"]
var array3:Array&lt;String&gt; = ["A","B","C"]    

// 空数组
var emptyArray = [Int]()    // var str = String()  空字符串
var emptyArray2 = Array&lt;String&gt;()

// 清空数组
array2 = [] 
array3 = [String]()

let numericArray = Array(count: 3, repeatedValue: 42)
// numericArray is [42, 42, 42]
</code></pre>

<h4>数组的基本运用</h4>

<pre><code>// 合并
var array = [0, 1, 2, 3]
array += [4, 5, 6]
// array is [0, 1, 2, 3, 4, 5, 6]

// Range
var subscriptableArray = ["zero", "one", "two", "three"]
let subRange = subscriptableArray[1...3]
// subRange = ["one", "two", "three"]  注意subRange是一个数组

subscriptableArray[1...3] = "oneonw" // error

subscriptableArray[1...2] = ["oneone", "twotwo"]
// subscriptableArray is now ["zero", "oneone", "twotwo", "three"]

// 数组遍历---同时取得索引和元素
for (index,item) in enumerate(stringArray){
    println("\(index) - \(item)")
}
</code></pre>

<h3>字典Dictionary</h3>

<p><code>Dictionary&lt;Key: Hashable, Value&gt;</code></p>

<blockquote><p>键可<code>哈希化</code></p></blockquote>

<h4>字典的定义</h4>

<pre><code>var emptyDictionary = Dictionary&lt;String: Int&gt;()
var equivalentEmptyDictionary = [String: Int]()
</code></pre>

<h4>字典的基本运用</h4>

<pre><code>// 更新或添加新值  updateValue(_:forKey:)
var dictionary = ["one": 1, "two": 2, "three": 3]

if let unwrappedPreviousValue = dictionary.updateValue(33, forKey: "three") {
    println("Replaced the previous value: \(unwrappedPreviousValue)")
} else {
    println("Added a new value")
}
// prints "Replaced the previous value: 3"

// 字典遍历
var dictionary = ["one": 1, "two": 2, "three": 3]

for (key,value) in dictionary{
    println("\(key) - \(value)")
}

// 字典键、值 的数组

var keys: LazyBidirectionalCollection&lt;MapCollectionView&lt;[Key : Value], Key&gt;&gt; { get }

let array = Array(dictionary.keys)
// array is ["one", "three", "two"]

var values: LazyBidirectionalCollection&lt;MapCollectionView&lt;[Key : Value], Value&gt;&gt; { get }

let array = Array(dictionary.values)
// array is [1, 3, 2]
</code></pre>

<h2>switch</h2>

<pre><code>let someCharacter: Character = "e"
switch someCharacter {
case "a", "e", "i", "o", "u":
    println("\(someCharacter) is a vowel")
case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m":
    println("\(someCharacter) is a consonant")
default:
    println("\(someCharacter) is not a vowel or a consonant")
}
// prints "e is a vowel"

// Range Matching
let count = 3_000
let countedThings = "stars in the Milky Way"
var naturalCount: String
switch count {
case 100..&lt;1000:
    naturalCount = "hundreds of"
case 1000...999_999:
    naturalCount = "thousands of"
default:
    naturalCount = "millions and millions of"
}
println("There are \(naturalCount) \(countedThings).")
// prints There are thousands of stars in the Milky Way.

// Tuples  下划线忽略部分数值
let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    println("(0, 0) is at the origin")
case (_, 0):
    println("on the x-axis")
case (0, _):
    println("on the y-axis")
case (-2...2, -2...2):  
    println("inside the box")
default:
    println("outside of the box")
}
// prints "inside the box"


// Value Bindings 判断一值，接收一值

let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    println("on the x-axis with an x value of \(x)")
case (0, let y):
    println("on the y-axis with a y value of \(y)")
case let (x, y):
    println("somewhere else at (\(x), \(y))")
}
// prints "on the x-axis with an x value of 2"

// where 
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    println("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    println("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    println("(\(x), \(y)) is just some arbitrary point")
}
// prints "(1, -1) is on the line x == -y"


let nickName = "Limon"
switch nickName{
    case let str where str.hasSuffix("on"):
        println("\(str)")
    default:
        println("He is not Limon")
}


// Fallthrough，局限：case条件中不能使用变量
let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime number, and also"
    fallthrough   // 继续往下case
default:
    description += " an integer!"
}
println(description)
// prints "The number 5 is a prime number, and also an integer!"
</code></pre>

<h2>函数 func</h2>

<h3>使用元组让函数返回多个值</h3>

<pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {

        currentMin = min(currentMin, value)
        currentMax = max(currentMax, value)
    }
    return (currentMin, currentMax)
}
</code></pre>

<h3>内部参数名和外部参数名 Shorthand External Parameter Names</h3>

<pre><code>func containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
    for character in string {
        if character == characterToFind {
            return true
        }
    }
    return false
}

containsCharacter(string: "aardvark", characterToFind: "v")
</code></pre>

<h3>参数默认值 Default Parameter Values</h3>

<pre><code>func sayHello(nickName:String, greeting:String = "Hello", other:String = "How are you") -&gt; String{
    let result = greeting + ", " + nickName + "! " + other
    return result
}

sayHello("Limon", other: "How do you do")
</code></pre>

<h3>可变参数 Variadic Parameters</h3>

<pre><code>func add(a:Int, b:Int, others:Int ...)-&gt;Int{
    var result = a + b
    for number in others{
        result += number
    }
    return result
}

add(3, 2)
add(3, 2, 1)
</code></pre>

<blockquote><p>在OC中，定义可变参数的函数需要用<code>va_list _arguments</code></p></blockquote>

<h3>引用参数 In-Out Parameters</h3>

<pre><code>func swapTwoInts(inout a: Int, inout b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt) // 传引用
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// prints "someInt is now 107, and anotherInt is now 3"
</code></pre>

<h2>闭包 Closures</h2>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
var reversed = sorted(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 })
reversed = sorted(names, { s1, s2 in return s1 &gt; s2 } ) // 简化
</code></pre>

<h3>Trailing Closures</h3>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
let reversed = sorted(names){ (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 }
</code></pre>

<h2>枚举 Enumerations</h2>

<h3>枚举定义</h3>

<pre><code>enum CompassPoint {
    case North
    case South
    case East
    case West
}

enum Planet {
    case Mercury, Venus, Earth, Mars, Jupiter   }
</code></pre>

<blockquote><p>不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面
枚举（Enumerations）
枚举语法的 CompassPoints 例子中， North ， South ， East 和 West 不是隐式的等于 0 ， 1 ， 2 和 3，但可定义的时候赋值，如下</p></blockquote>

<pre><code>enum Number:Int {
    case one=1, two, three, four, five
}   

var userInputNumber = 1
if let theNumber = Number(rawValue: userInputNumber) // 相当于解包
{
    switch theNumber{
        case .one:println("the number is 1")
        default: println("no number")
    }
}
</code></pre>

<h3>相关值 Associated Values</h3>

<pre><code>enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}

var productA = Barcode.UPCA(8, 85909_51226, 3)
var productB:Barcode = .QRCode("ABCDEFGHIJKLMNOP")

switch productB {
    case .UPCA(let numberSystem, let identifier, let check):
        println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
    case .QRCode(let productCode):
        println("QR code with value of \(productCode).")
}
// 输出 "QR code with value of ABCDEFGHIJKLMNOP.”
</code></pre>

<h2>官方文档</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0">The Swift Programming Language</a>  &mdash;&ndash; Swift官方文档</p>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html#//apple_ref/doc/uid/TP40014608-CH7-SW1">Swift Standard Library Reference</a>  &mdash;&ndash; 基础类型的文档</p>

<h2>Cheat Sheet</h2>

<p><a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/RW-Swift-Cheatsheet-0_3.pdf">Swift Cheat Sheet and Quick Reference</a></p>

<p><a href="http://mhm5000.gitbooks.io/swift-cheat-sheet/content/index.html">Swift Cheat Sheet</a></p>

<p><a href="https://github.com/iwasrobbed/Swift-CheatSheet#swift-cheat-sheet">Swift-CheatSheet</a></p>

<p><a href="http://kpbp.github.io/swiftcheatsheet/#variables">Swift Cheat Sheet</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理 - ARC]]></title>
    <link href="http://limon-.github.io//blog/2015/01/22/nei-cun-guan-li-arc/"/>
    <updated>2015-01-22T18:20:16+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/22/nei-cun-guan-li-arc</id>
    <content type="html"><![CDATA[<h2>什么是ARC</h2>

<p>Automatic Reference Counting，自动引用计数，即ARC。</p>

<p>在ARC下，不需用retain,release,autorelease,dealloc来管理内存，它提供了自动评估内存生存期的功能，并且在编译期间自动加入合适的管理内存的方法。编译器也会自动生成dealloc函数。</p>

<h3>ARC工作原理</h3>

<p>ARC并不是一项运行时的服务，实际上它是由Clang front-end提供的两段过程。下图演示了这两段过程。在front-end段时，Clang检查每个预处理文件的对象和属性。然后它跟据一些固定的规则将retain，release和autorelease语句加入其中。</p>

<blockquote><p>实际上，ARC在调用retain,release,autorelease,dealloc方法时，并不通过Objective-C消息派送机制，而是直接调用C。比如，ARC会调用与retain等价的objc_retain</p></blockquote>

<p><img src="http://limons-gitimage.stor.sinaapp.com/CFigure4.gif" alt="" /></p>

<p>举例来说：</p>

<ul>
<li>如果对象被分配内存并处于一个方法当中，它会在这个方法的结尾处获得一个release语句</li>
<li>如果是一个类属性，它的release语句会加入到类的dealloc方法中</li>
<li>如果这个对象是用来返回的或者它是一个容器对象，它会加入一个autorelease语句</li>
<li>如果这个对象是弱引用，把它放在一边不管它。</li>
</ul>


<blockquote><p>译于：<a href="http://www.drdobbs.com/mobile/automatic-reference-counting-on-ios/240000820">Automatic Reference Counting on iOS</a></p></blockquote>

<h3>代码演示</h3>

<h4>MRC下</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@class Bar;
</span><span class='line'>@interface Foo
</span><span class='line'>{
</span><span class='line'>@private
</span><span class='line'>    NSString *myStr;
</span><span class='line'>}
</span><span class='line'>@property (readonly) NSString *myStr;
</span><span class='line'>  
</span><span class='line'>- (Bar *)foo2Bar:(NSString *)aStr;
</span><span class='line'>- (Bar *)makeBar;
</span><span class='line'>//...
</span><span class='line'>@end
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>@implementation Foo;
</span><span class='line'>@dynamic myStr;
</span><span class='line'>  
</span><span class='line'>– (Bar *)foo2Bar:(NSString *)aStr
</span><span class='line'>{
</span><span class='line'>    Bar *tBar;
</span><span class='line'>      
</span><span class='line'>    if (![self.myStr isEqualToString:aStr])
</span><span class='line'>    {
</span><span class='line'>        [aStr retain];
</span><span class='line'>        [myStr release];
</span><span class='line'>        myStr = aStr;
</span><span class='line'>    }  
</span><span class='line'>    return ([self makeBar]);
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>- (Bar *)makeBar
</span><span class='line'>{
</span><span class='line'>    Bar *tBar
</span><span class='line'>    //...
</span><span class='line'>    //... conversion code goes here
</span><span class='line'>    //...
</span><span class='line'>    [tBar autorelease];
</span><span class='line'>    return (tBar);
</span><span class='line'>}
</span><span class='line'>//...
</span><span class='line'>  
</span><span class='line'>- (void)dealloc
</span><span class='line'>{
</span><span class='line'>    [myStr release];
</span><span class='line'>    [super dealloc];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h4>ARC下</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@class Bar;
</span><span class='line'>@interface Foo
</span><span class='line'>{
</span><span class='line'>@private
</span><span class='line'>    NSString *myStr;
</span><span class='line'>}
</span><span class='line'>@property(readonly) NSString *myStr;
</span><span class='line'>  
</span><span class='line'>- (Bar *)foo2Bar:(NSString *)aStr;
</span><span class='line'>- (Bar *)makeBar;
</span><span class='line'>//...
</span><span class='line'>@end
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>@implementation Foo;
</span><span class='line'>@dynamic myStr;
</span><span class='line'>  
</span><span class='line'>– (Bar *)foo2Bar:(NSString *)aStr
</span><span class='line'>{
</span><span class='line'>    Bar *tBar;
</span><span class='line'>      
</span><span class='line'>    if (![self.myStr isEqualToString:aStr])
</span><span class='line'>    {
</span><span class='line'>        myStr = aStr;
</span><span class='line'>    }  
</span><span class='line'>    return ([self makeBar]);
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>- (Bar *)makeBar
</span><span class='line'>{
</span><span class='line'>    Bar *tBar
</span><span class='line'>    //...
</span><span class='line'>    //... conversion code goes here
</span><span class='line'>    //...
</span><span class='line'>    return (tBar);
</span><span class='line'>}
</span><span class='line'>//...
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<blockquote><p>以上代码来源于：<a href="http://www.drdobbs.com/mobile/automatic-reference-counting-on-ios/240000820">Automatic Reference Counting on iOS</a></p></blockquote>

<h2>ARC下内存管理 &mdash; 内存管理语义</h2>

<p>ARC帮助我们解决90%内存管理为题，剩余的10%包括：</p>

<ul>
<li>属性(property)的内存管理语义是用strong、还是weak？</li>
<li>循环引用（retain cycle）问题</li>
<li>CoreFoundation对象不归ARC管理</li>
</ul>


<h3>属性</h3>

<p>属性(property)是Objective-C的一项特性，用于封装对象中的数据。Objective-C对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过getter、setter来访问。</p>

<p><code>@property(nonatomic, strong) NSArray *emailList;</code></p>

<p>此<code>@property</code>会自动生成三个东西：_emailList实例变量、getter、setter</p>

<p>属性用于封装数据，而数据则要有“具体的所有权语义”(concrete ownership semantic)，也称为内存管理语义。</p>

<p>回归本题，在ARC下，我们通常用<strong>内存管理语义</strong>来管理内存，下面这一组语义仅会影响setter。例如，用setter设定一个新值时，它是应该“保留”(retain)此值呢，还是只将其赋给底层实例变量就好？这些取决于你是用strong，还是copy，还是assign等</p>

<ul>
<li><p><code>assign</code>  对“纯量类型”(scalar type)的简单赋值</p>

<pre><code>  -(void)setState:(int)State{  
      _state = state;  
  }
</code></pre></li>
<li><p><code>unsafe_unretained</code>  此语义与<code>assign</code>相同，但是它适用于&#8221;对象类型&#8221;，该语义表达一种&#8221;非拥有关系&#8221;(unretained),当对象被销毁时，属性值不会自动清空(&ldquo;不安全&rdquo;,unsafe)，这一点与<code>weak</code>有区别</p></li>
<li><p><code>weak</code>  该语义表达一种&#8221;非拥有关系&#8221;，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，即仅作简单赋值，类似<code>assign</code>，当对象销毁，属性值被赋值为<code>nil</code></p></li>
<li><p><code>strong</code>  该语义表达一种&#8221;拥有关系&#8221;，为这种属性值设置新值时，设置方法会先保留新值，再释放旧值，最后把新值设置上去</p>

<pre><code>  -(void)setName:(NSArray *)emailList{    
      if ( emailList != _emailList){
          [emailList retain]; // 保留新值
          [_emailList release]; // 释放旧值
          _emailList = emailList;
      }   
  }
</code></pre></li>
</ul>


<p>此setter将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要，假如两个值都指向对象A，还未保留新值就先把旧值释放了，那么先执行的release操作就可能导致对象A被回收，而后续的retain操作并无法令对象A复生，于是实例变量就成了悬挂指针</p>

<blockquote><p>当所指向的对象被释放或者收回，此情况下该指针便称悬垂指针（也叫迷途指针）。</p></blockquote>

<ul>
<li><p>copy  此语义与strong类似，不同在于setter并不保留新值，而是将其<code>copy</code>，如下：</p>

<pre><code>  @property (nonatomic, copy) NSString *name;

  -(void)setName:(NSString*)name{  
      if ( name != _name){  
          [_name release];
          _name = nil;
          _name = [name copy]; 
      }  
  }
</code></pre></li>
</ul>


<p>使用copy可以用来保护数据的封装性，比方说，传递过来的新值是一个NSMutableString的实例，此时若不<code>copy</code>，当设置完属性值之后，该可变新值在对象不知情的情况下遭人更改。所以，这时就要<code>copy</code>一份“不可变”(immutable)的字符串，确保对象中的字符串值不会不会无意间变动。</p>

<h3>ARC下内存管理 &mdash; 基本规则</h3>

<p>ARC下内存管理的一个基本规则：只要某个对象被任一strong指针指向，那么它将不会被回收。</p>

<h4>strong</h4>

<p>在MRC下，如果想令一个对象继续存活，需用retain来递增计数器，不过ARC已经在编译时帮我们加入了retain、release等，现在唯一需要的是，用一个强指针指向该对象，只要指针没有被空置，该对象会一直在堆上。</p>

<blockquote><p>实际上，不论MRC和ARC下，还是在用引用计数来管理内存，具体请看：<a href="http://limon-.github.io/blog/2015/01/13/nei-cun-guan-li-yin-yong-ji-shu-qi/">内存管理 - 引用计数器</a></p></blockquote>

<p>在默认情况下，所有的实例变量和局部变量都是strong类型的。可以说strong类型的指针在行为上和MRC时代的retain是比较相似的。</p>

<h4>weak</h4>

<p>weak常用在两个对象间存在包含关系时：对象A有一个strong指针指向对象B，并持有它，而对象B中也有一个weak指针指回对象B，从而避免了循环持有。</p>

<p>一个常见的例子就是delegate设计模式，viewController中有一个strong指针指向它所负责管理的UITableView，而UITableView中的dataSource和delegate指针都是指向viewController的weak指针。可以说，weak指针的行为和MRC时代的assign有一些相似点，但是考虑到weak指针更聪明些（会自动指向nil）</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/arcpic7.png" alt="" /></p>

<blockquote><p>代理模式可以简单认为，两个对象之间形成&#8221;半保留环&#8221;（A对象强指针指向B对象，B对象弱指针指向A对象）</p></blockquote>

<h3>ARC下内存管理 &mdash; 循环引用</h3>

<p>接下来简单讲讲容易循环引用的场景，详情请看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW3">官方文档</a>的相关资料</p>

<h4>委托模式</h4>

<pre><code>@property (nonatomic,weak) id&lt;ComposeToolbarButtonTypeDelegate&gt; delegate; 
</code></pre>

<p>用<code>weak</code>形成“半保留环”，防止循环引用</p>

<h4>block</h4>

<p>这个网上大把，可以看看<a href="http://www.cnbluebox.com/?p=255">block使用小结、在arc中使用block、如何防止循环引用</a></p>

<h3>ARC下内存管理 &mdash; self</h3>

<p>ARC下，方法内的self既不是strong也不是weak，而是unsafe_unretained的（init系列方法的self除外）。
换而言之，在普通方法中，ARC不会对<code>self</code>做<code>retain</code>和<code>release</code>操作，生命周期全由调用方来决定，如果调用方没有保证<code>self</code>在被调用方法中的生命周期，可能在此方法中运行到一半，<code>self</code>就被释放了，可能程序就崩溃了。</p>

<h2>总结</h2>

<ul>
<li>ARC管理对象生命期的基本办法：在编译期间，在合适的地方插入<code>retain</code>和<code>release</code>操作</li>
<li>在ARC下，我们通常通过<code>内存管理语义</code>来管理内存，常见的有：<code>strong</code>、<code>weak</code>、<code>copy</code></li>
</ul>


<h2>番外</h2>

<p>研读了@sunny大大的<a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">《ARC对self的内存管理》</a>之后作一些笔记，</p>

<h2>参考资料</h2>

<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">Objective-C Automatic Reference Counting (ARC)</a> &mdash;&ndash; 关于ARC的详细文档</p>

<p><a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">ARC对self的内存管理</a> &mdash;&ndash; 专门对ARC下self的剖析</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理 - Autorelease]]></title>
    <link href="http://limon-.github.io//blog/2015/01/19/autoreleasepool/"/>
    <updated>2015-01-19T16:12:34+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/19/autoreleasepool</id>
    <content type="html"><![CDATA[<p>Autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用release，也就是计数器会减1，但是自动释放池被销毁了，里面的对象并不一定会被销毁。</p>

<p>简而言之，autorelease pool 避免了频繁申请/释放内存。</p>

<h2>pool什么时候被销毁？</h2>

<p>在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，此pool内的OC对象会被release。
那什么是一个Runloop呢？ 一个UI事件，Timer call， delegate call， 都会是一个新的Runloop</p>

<p>在Iphone项目中，大家会看到一个默认的Autorelease pool，程序开始时创建，程序退出时销毁，按照对Autorelease的理解，岂不是所有autorelease pool里的对象在程序退出时才release， 这样跟内存泄露有什么区别？</p>

<p>答案是，对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个栈式结构，遵循先进后出，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个OC对象会被release。</p>

<h2>pool嵌套，栈式结构</h2>

<p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个栈式结构，遵循先进后出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>#import "Person.h" 
</span><span class='line'>int main(int argc, const char * argv[]) 
</span><span class='line'>{ 
</span><span class='line'>     
</span><span class='line'>    // 自动释放池1 
</span><span class='line'>    @autoreleasepool { 
</span><span class='line'>         
</span><span class='line'> // 对象的释放交给 自动释放池去管理 不用再写[person release] 
</span><span class='line'>        Person *person = [[Person alloc] init];  
</span><span class='line'>         
</span><span class='line'>        // 再创建一个自动释放池2 
</span><span class='line'>        @autoreleasepool { 
</span><span class='line'>             
</span><span class='line'>            Person *person2 = [[Person alloc] init]; 
</span><span class='line'>        } 
</span><span class='line'>        
</span><span class='line'>        Person *person3 = [[Person alloc] init];    
</span><span class='line'>    } 
</span><span class='line'>    return 0; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>pool2先被销毁，最后才是pool1，即释放顺序：person2 -> person3/person2</p>

<h3>#</h3>

<h4>一下内容整理于 #<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></h4>

<p>在ARC下，<code>@autoreleasepool{}</code>创建一个AutoreleasePool，随后编译器将其改写成下面的样子：</p>

<pre><code>void *context = objc_autoreleasePoolPush();
// {}中的代码
objc_autoreleasePoolPop(context);
</code></pre>

<p>而这两个函数都是对AutoreleasePoolPage的简单封装，所以自动释放机制的核心就在于这个类。</p>

<pre><code>class AutoreleasePoolPage 
{
    .....
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
    ....
}
</code></pre>

<ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>


<h2>总结</h2>

<ul>
<li>autorelease方法不会改变对象的引用计数器，只是将这个对象放到自动释放池中；</li>
<li>自动释放池实质是当自动释放池销毁后调用对象的release方法，不一定就能销毁对象（例如如果一个对象的引用计数器>1则此时就无法销毁）；</li>
<li>由于自动释放池最后统一销毁对象，因此如果一个操作比较占用内存（对象比较多或者对象占用资源比较多），最好不要放到自动释放池或者考虑放到多个自动释放池；</li>
<li>ObjC中类库中的静态方法一般都不需要手动释放，内部已经调用了autorelease方法；</li>
</ul>


<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>

<p><a href="http://www.cnblogs.com/kenshincui/p/3870325.html#autoreleasepool">Objective-C之内存管理</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading record]]></title>
    <link href="http://limon-.github.io//blog/2015/01/19/reading-record/"/>
    <updated>2015-01-19T10:16:07+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/19/reading-record</id>
    <content type="html"><![CDATA[<h2>Swift</h2>

<h2>ReactiveCocoa</h2>

<p><a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">ReactiveCocoa 用 RACSignal 替代 Delegate</a></p>

<h2>内存管理</h2>

<p><a href="http://www.oschina.net/translate/automatic-reference-counting-on-ios">iOS开发之ARC</a></p>

<p><a href="http://onevcat.com/2012/06/arc-hand-by-hand/">手把手教你ARC——iOS/Mac开发ARC入门和使用</a></p>

<p><a href="http://blog.csdn.net/nicktang/article/details/6792972">IOS 5编程 内存管理 ARC技术概述</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-1/">iPhone开发之深入浅出 (1) — ARC是什么</a></p>

<h2>线程</h2>

<p><a href="http://blog.cnbluebox.com/blog/2014/07/01/cocoashen-ru-xue-xi-nsoperationqueuehe-nsoperationyuan-li-he-shi-yong/">Cocoa深入学习:NSOperationQueue、NSRunLoop和线程安全</a></p>

<p><a href="http://www.cnblogs.com/kenshincui/p/3983982.html">iOS开发系列&ndash;并行开发其实很容易</a></p>

<h2>动画</h2>

<p><a href="http://yingkong1987.github.io/blog/2014/05/05/playing-with-pop.html">玩转Facebook开源的Pop库</a></p>

<p><a href="http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-3-0">iOS开发系列&ndash;让你的应用“动”起来</a></p>

<h2>CocoaPods</h2>

<p><a href="http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">用CocoaPods做iOS程序的依赖管理</a></p>

<p><a href="http://gracelancy.com/blog/2013/08/11/make-your-own-cocoapods-spec/">制作自己的CocoaPods Spec</a></p>

<p><a href="http://www.iwangke.me/2013/04/18/advanced-cocoapods/">CocoaPods进阶：本地包管理</a></p>

<h2>杂</h2>

<p><a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/">64-bit Tips</a></p>

<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>

<p><a href="http://mobile.51cto.com/iphone-284112.htm">Objective-C内存管理如何理解Autorelease</a></p>

<p><a href="http://cocoa.venj.me/blog/view-controller-based-status-bar-style-and-uinavigationcontroller/#comment-1501032470">UINavigationController和View Controller-based状态栏风格</a> &mdash;&mdash; 指定状态栏风格</p>

<p><a href="http://gracelancy.com/blog/2014/05/05/variable-argument-lists/">Variable Argument Lists</a> &mdash;&mdash; 可变参数函数的定义</p>

<p><a href="http://www.imooc.com/wenda/detail/244497">100个iOS开发/设计面试题汇总</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理 - 引用计数]]></title>
    <link href="http://limon-.github.io//blog/2015/01/13/nei-cun-guan-li-yin-yong-ji-shu-qi/"/>
    <updated>2015-01-13T14:27:14+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/13/nei-cun-guan-li-yin-yong-ji-shu-qi</id>
    <content type="html"><![CDATA[<h2>内存管理概述</h2>

<p>在Objective-C中，系统并不会自动释放堆中的内存，其他高级语言C#、JAVA都有垃圾回收机制，但在Objective-C中并没有垃圾回收机制，那么Objective-C中的内存是如何管理？
Objective-C语言使用引用计数器来管理内存，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数器；用完之后，就递减其计数器；当计数器为0，就表示没人关注此对象，此对象就会被销毁。</p>

<h2>引用计数工作原理</h2>

<p>在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活。
NSObject协议声明了三个方法用于操作计数器</p>

<ul>
<li>Retain 递增计数器</li>
<li>Release 递减计数器</li>
<li>autorelease 待销毁autorelease pool时，再递减pool内的全部计数器</li>
</ul>


<p>1.对一个对象发送alloc、retain、new、copy消息，计数器 +1</p>

<p>2.对一个对象发送release消息，计数器 -1</p>

<p>3.当一个对象的引用计数器为0，对象就被回收(dealloced)，也就是说，系统会将对象其占用的内存标记为“可重用”(reuse)，放到“可用内存池”(avaiable pool)</p>

<h3>手动管理内存的三点原则</h3>

<ul>
<li>如果需要持有一个对象，那么对其发送retain</li>
<li>如果之后不再使用该对象，那么需要对其发送release（或者autorealse）</li>
<li>每一次对retain,alloc或者new的调用，需要对应一次release或autorealse调用</li>
</ul>


<h3>图表演示</h3>

<p>下图演示了一个对象自创建出来之后经历一次retain及两次release操作的过程</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/Memory.png" alt="Memory" /></p>

<p>下图所示的对象图中，ObjectB和ObjectC都引用了ObjectA，若B和C都不再使用A，则其计数器为0，便被回收。还有OrderObject想令B和C继续存活，而应用程序里又有另外的对象想令OrderObject继续存活，如果按“引用树“回溯，那么会发现一个“根对象”，在iOS中，则是UIApplication对象。此”根对象”是应用程序启动时创建的单例。</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/Memory-2.png" alt="Memory" /></p>

<h3>代码演示</h3>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    NSMutableArray *array = [[NSMutableArray alloc] init];
    NSNumber *number = [[NSNumber alloc] initWithInt:1337]; 

    [array addObject:number]; //number的引用计数器+1（此时number的引用计数器至少为2）
    [number release]; // -1

    // do something with `array’

    [array release];
    return YES;
}
</code></pre>

<blockquote><p>在调用数组的<code>-addObject</code>方法时，数组也会在number上调用retain，以期令此对象存活</p></blockquote>

<h2>引用计数的应用场景</h2>

<p>在上面的代码演示中，还不看出引用计数的真正用处。在函数内使用一个临时的对象，通常不需要修改引用计数，只需在返回前将该对象销毁即可。
引用计数真正的应用场景是，用于对象之间传递和共享数据。</p>

<h2>引用计数的注意要点</h2>

<h3>retainCount可能永远不为0</h3>

<p>可能有人会测试对象释放时，看retainCount是否为0，代码如下：</p>

<pre><code>NSObject *object = [[NSObject alloc] init];
NSLog(@"%lu",(unsigned long)[object retainCount]);
[object release];
NSLog(@"%lu",(unsigned long)[object retainCount]);
</code></pre>

<p>但是，打印的结果是 1  1</p>

<p>最后一次输出，引用计数并没有变成0，原因是在最后一次 release 时，系统马上就回收了内存，就没有再将retainCount减1，因为不将值从1变成0，可以减少一次内存操作，加快对象的回收，只有在系统不打算这么优化时，计数值才会递减为0</p>

<h3>悬挂指针</h3>

<p>当所指向的对象被释放或者收回，此情况下该指针便称悬垂指针（也叫迷途指针）。</p>

<blockquote><p>某些编程语言允许未初始化的指针的存在，而这类指针即为野指针。</p></blockquote>

<p>为什么对象被回收了，向其发送消息不会崩？代码如下：</p>

<pre><code>NSNumber *number = [[NSNumber alloc] initWithInt:1337];

[number release];

NSLog(@"number = %@",number);
</code></pre>

<p>内存已经被回收，如果向其发送消息，可能使程序崩溃。为什么说“可能”，而没说“一定”，是因为对象的所占的内存在“解除分配”(deallocated)之后，只是放回了“可用内存池”(avaiable pool)。如果在执行NSLog时尚未覆写对象内存，那么该对象仍然有效。</p>

<blockquote><p>由此可见，因过早释放对象而导致的bug很难调试</p></blockquote>

<p>为了防止此情况的发送，一般release之后都会清空指针</p>

<pre><code>NSNumber *number = [[NSNumber alloc] initWithInt:1337];

[number release];
number = nil; 
</code></pre>

<blockquote><p>在Objective-C中，向nil发送消息不会出错。</p></blockquote>

<h2>总结</h2>

<ul>
<li>Objective-C通过<code>引用计数机制</code>来管理内存</li>
<li>对象创建之后，其引用计数器至少为1，<code>retain</code>和<code>release</code>分别会递增及递减计数器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬支付宝的各种坑]]></title>
    <link href="http://limon-.github.io//blog/2015/01/07/pa-zhi-fu-bao-de-ge-chong-keng/"/>
    <updated>2015-01-07T13:57:57+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/07/pa-zhi-fu-bao-de-ge-chong-keng</id>
    <content type="html"><![CDATA[<p>爬了几天坑，在笔者崩溃之际终于集成好了，在这里分享一下经验。</p>

<p>笔者用的是<code>支付宝移动支付SDK标准版(iOS 2.1.2)</code>，申请的手机快捷支付</p>

<h2>密钥</h2>

<p>利用支付宝给的<code>openssl.exe</code>工具生成一共三种密钥，私钥、公钥，PKCS8类型的私钥</p>

<ul>
<li>公钥：放在支付宝上，去掉首尾的<code>-----BEGIN PUBLIC KEY-----``-----END PUBLIC KEY-----</code></li>
<li>PKCS8类型的私钥：如果选择在手机端签名，此私钥放在<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
<li>私钥：此私钥带有<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>，是专门给PHP用的，即在服务器端(PHP)签名，需要用到此私钥

<blockquote><p>Note：推荐服务器端签名，不过需要注意的是，PHP端用的是带<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>的私钥。</p></blockquote></li>
</ul>


<h2>集成支付宝</h2>

<p>按照文档给的流程理论上想运行Demo是挺容易的，需要注意：</p>

<ul>
<li>Demo是在本地签的名，所以Demo上填写<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
</ul>


<p>如果认为看似Demo超简单，你就错了。</p>

<h3>坑一：Undefined symbols for architecture x86_64:</h3>

<p>笔者爬过的坑，<code>ssl库</code>不支持x86_64就是64位模拟器。（若在服务器端签名不需引入ssl库）</p>

<blockquote><p>程序界公认女神@念茜给出的答案。。。</p></blockquote>

<p>也就是以下这种错误</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/alipay.png" alt="alipay error" /></p>

<p>针对这个错误，笔者尝试了各种方法，Architectures的各种设置，甚至都是一行一行对着Demo来改的，还有C++ Flage等等，最终还是不行。</p>

<p>和客服聊了一个多小时，最后客服把支付宝最老的版本和13年的版本给笔者。。。。挺好人的。。。。</p>

<h3>坑二：rsaSign()和rsaVerify()</h3>

<p>作为一个技术渣，iOS我是搞不掂了，还是搞PHP吧。。。</p>

<p>吐血的是，笔者用支付宝给的PHP版Demo，用它里面的方法<code>rsaSign()</code>签名，然后再用<code>rsaVerify()</code>验签，结果<code>rsaVerify()</code>返回的结果永远都是false，后来笔者终于准备出坑了，醒悟这个<code>rsaVerify()</code>应该不是验证这签名的。</p>

<p>后来百度了解了点皮毛：</p>

<p>RSA非对称密钥</p>

<p>① 假设A、B机器进行通信，已A机器为主；</p>

<p>② A首先需要用自己的私钥为发送请求数据签名，并将公钥一同发送给B；</p>

<p>③ B收到数据后，需要用A发送的公钥进行验证，已确保收到的数据是未经篡改的；</p>

<p>④ B验签通过后，处理逻辑，并把处理结果返回，返回数据需要用A发送的公钥进行加密（公钥加密后，只能用配对的私钥解密）；</p>

<p>⑤ A收到B返回的数据，使用私钥解密，至此，一次数据交互完成。</p>

<blockquote><p><code>rsaVerify</code>笔者猜测是验证支付宝的回调的。换句话说，签名直接就用<code>rsaSign()</code>就好了，就以下这几行代码</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>include('alipay_rsa.function.php');
</span><span class='line'>
</span><span class='line'>$data = $_POST['data'];
</span><span class='line'>$sign = rsaSign($data,'../key/rsa_private_key.pem');
</span><span class='line'>
</span><span class='line'>$arr = array(
</span><span class='line'>  'sign' =&gt; $sign
</span><span class='line'>);
</span><span class='line'>
</span><span class='line'>echo json_encode($arr);
</span><span class='line'>?&gt;</span></code></pre></td></tr></table></div></figure>


<p>以为这样就爬完了？</p>

<h3>坑三：urlEncoded</h3>

<p>想着服务器直接返回<code>sign</code>直接再拼接一下就提交给支付宝，结果又掉坑里。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic).....
</code></pre>

<p>又跑去和客服聊天，笔者问客服：服务器返回的<code>sign</code>应该还需要<code>urlEncoded</code>对吧，客服回我说：不用啊，服务器已经弄了啊。</p>

<pre><code>/**
* RSA签名
* @param $data 待签名数据
* @param $private_key_path 商户私钥文件路径
* return 签名结果
*/
function rsaSign($data, $private_key_path) {
    $priKey = file_get_contents($private_key_path);
    $res = openssl_pkey_get_private($priKey);
    openssl_sign($data, $sign, $res);
    openssl_free_key($res);
    //base64编码
    $sign = base64_encode($sign);
    return $sign;
}
</code></pre>

<p>客服说<code>base64_encode($sign)</code>完就可以了不需要<code>urlEncoded</code>。笔者果断还是不相信客服。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

// 深坑啊......    
signedString = [self urlEncodedString:signedString];

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic)....
</code></pre>

<p>需要在<code>RSADataSigner.m</code>中抽离<code>-urlEncodedString</code>方法出来。。。坑啊，明明都不需要手机端签名了，当然不会去看手机端签名的具体流程啦。又没看到哪里说明服务器端返回的<code>sign</code>需要<code>urlEncoded</code>，连客服都不知道需要<code>urlEncoded</code>&hellip;..</p>

<h3>心塞，不说了&hellip;&hellip;.</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa]]></title>
    <link href="http://limon-.github.io//blog/2014/09/03/reactivecocoa/"/>
    <updated>2014-09-03T17:44:25+08:00</updated>
    <id>http://limon-.github.io//blog/2014/09/03/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<h2>RACSignal</h2>

<h3>订阅RACSignal</h3>

<p>1.RACSignal (Subscription)
RACSignal (Subscription)类别可以看到所有的订阅事件的方法，每个方法都会将类型为(void (^)(id x))的block作为参数，当事件发生时block中的代码会执行，例如-subscribeNext:方法会传入一个block作为参数，当Signal的next事件发出后，block会接收到事件并执行。</p>

<p>2.UIKit Category
RAC为UIKit添加了很多类别来让我们可以订阅UI组件的事件，比如UITextField (RACSignalSupport)中的rac_textSignal会在文本域内容变化时发出next事件。
事件包含的内容可以是类型，只要是对象就行，如果是一些数字，布尔值等字面量，可以用@()语法装箱成NSNumber。</p>

<h3>操纵Signal</h3>

<h5>1.RACStream (Operations)</h5>

<p><code>-filter</code>:uses a block to test each value. Returns a new stream with only those values that passed.</p>

<pre><code>- (instancetype)filter:(BOOL (^)(id value))block;
    RACSequence *numbers = [@"1 2 3 4 5 6 7 8 9" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: 2 4 6 8
RACSequence *filtered = [numbers filter:^ BOOL (NSString *value) {
    return (value.intValue % 2) == 0;
}];
</code></pre>

<p><code>-map</code>:Maps block across in the receiver , and transform the values. Returns a new stream with the mapped values.</p>

<pre><code>- (instancetype)map:(id (^)(id value))block;
    RACSequence *letters = [@"A B C D E F G H I" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: AA BB CC DD EE FF GG HH II
RACSequence *mapped = [letters map:^(NSString *value) {
    return [value stringByAppendingString:value];
}];
</code></pre>

<p><code>-flattenMap</code>:Maps block across the values in the receiver and flattens the result. It is used to signal of signal.简单理解为：取出内部的Signal.</p>

<pre><code>[[[self.signInButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
        map:^id(id x) {
            return [self signInSignal]; // 此signal内含一个BOOL signal
    }]
    subscribeNext:^(id x) {
        NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>打印出来的不是BOOL，<code>-subscribeNex</code>t: will execute the block whenever the signal sends a value. 但这value不包括 signal of signals：an outer signal that contains an inner signal.</p>

<pre><code>2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result: 
                        &lt;RACDynamicSignal: 0xa068a00&gt; name:+createSignal:
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[[self.signInButton
</span><span class='line'>   rac_signalForControlEvents:UIControlEventTouchUpInside]
</span><span class='line'>   flattenMap:^id(id x) { // subscribe to the inner signal within the outer signal’s
</span><span class='line'>     return [self signInSignal];
</span><span class='line'>   }]
</span><span class='line'>   // Output: Sign in result: 0
</span><span class='line'>   subscribeNext:^(id x) {
</span><span class='line'>     NSLog(@"Sign in result: %@", x);
</span><span class='line'>   }];</span></code></pre></td></tr></table></div></figure>


<h4>2.RACSignal (Operations)</h4>

<h2>RACObserve</h2>

<pre><code>// When self.username changes, logs the new name to the console.
//
// RACObserve(self, username) creates a new RACSignal that sends the current
// value of self.username, then the new value whenever it changes.
// -subscribeNext: will execute the block whenever the signal sends a value.
[RACObserve(self, username) subscribeNext:^(NSString *newName) {
    NSLog(@"%@", newName);
}];
</code></pre>

<h4>过滤signal</h4>

<pre><code>// Only logs names that starts with "j".
//
// -filter returns a new RACSignal that only sends a new value when its block
// returns YES.
[[RACObserve(self, username)
    filter:^(NSString *newName) {
        return [newName hasPrefix:@"j"];
    }]
    subscribeNext:^(NSString *newName) {
        NSLog(@"%@", newName);
}];
</code></pre>

<h2>Chip</h2>

<p><code>distinctUntilChanged</code>：Returns a stream of values for which -isEqual: returns NO when compared to the previous value.
用来确保signal只会发送不同的值,比较数值流中当前值和上一个值，如果不同，就返回当前值，简单理解,它将这一次的值与上一次做比较，当相同时（也包括- isEqual:）被忽略掉。</p>

<pre><code>RACSignal *validSearchSignal =
[[RACObserve(self, searchText)
  map:^id(NSString *text) {
     return @(text.length &gt; 3);
  }]
  distinctUntilChanged]; // ensure this signal only emits values when the state changes.

[validSearchSignal subscribeNext:^(id x) {
    NSLog(@"search text is valid %@", x);
}];

self.executeSearch =
[[RACCommand alloc] initWithEnabled:validSearchSignal // validSearchSignal决定button能不能点击
  signalBlock:^RACSignal *(id input) {
    return  [self executeSearchSignal];
  }];
</code></pre>

<p>例子二：比如UI上一个Label绑定了一个值，根据值更新显示的内容:</p>

<pre><code>RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];
self.user.username = @"sunnyxx"; // 1st
self.user.username = @"sunnyxx"; // 2nd
self.user.username = @"sunnyxx"; // 3rd 
</code></pre>

<p>所以，对于相同值可以忽略的情况，果断加上它吧。</p>

<p><code>-takeUntilBlock</code>：对于每个next值，运行block，当block返回YES时停止取值，如：</p>

<pre><code>[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) {
    return [value isEqualToString:@"stop"];
}] subscribeNext:^(NSString *value) {
    NSLog(@"current value is not `stop`: %@", value);
}];
</code></pre>

<blockquote><p>Note：停止取值的意思是，输入stop之后，无论输入什么都不会再取值，即输入stop之后，不会再有任何输出。
还有一个例子：</p></blockquote>

<pre><code>- (RACSignal*) rac_RequestStateSignal
{
    return [[RACObserve(self, state)
        takeUntilBlock:^ BOOL (NSNumber *state){
            return [state intValue] == iRequestStateComplete;
        }]
        flattenMap:^(NSNumber *state){
            if ([state intValue] == iRequestStateErrored)
            { 
                // Create a meaningful NSError here if you can.
                return [RACSignal error:nil];
            }
            else
            { 
                return [RACSignal return:state];
            }
        }];
}
</code></pre>

<p><code>-switchToLatest</code>方法用于signal-of-signals，它总是输出最新的信号的值。</p>

<pre><code>RACSubject *letters = [RACSubject subject];
RACSubject *numbers = [RACSubject subject];
RACSubject *signalOfSignals = [RACSubject subject];

RACSignal *switched = [signalOfSignals switchToLatest];

// Outputs: A B 1 D
[switched subscribeNext:^(NSString *x) {
    NSLog(@"%@", x);
}];

[signalOfSignals sendNext:letters]; // 打印letters信号内的值
[letters sendNext:@"A"];
[letters sendNext:@"B"];

[signalOfSignals sendNext:numbers]; // 打印numbers信号内的值
[letters sendNext:@"C"];
[numbers sendNext:@"1"];

[signalOfSignals sendNext:letters]; // 打印letters信号内的值
[numbers sendNext:@"2"];
[letters sendNext:@"D"];
</code></pre>

<p><code>-rac_signalForSelector:fromProtocol:</code></p>

<p>这个方法主要是把 protocal 转为一个 Signal 便于使用。值得注意的是这个函数返回的是一个 RACTuple。 这个 RACTuple 包含了 Selector 方法里面所有的参数</p>

<p><code>-rac_liftSelector:withSignalsFromArray:</code>
这个方法它的意思是当传入的 Signals 都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容。就会去触发第一个 selector 参数的方法。</p>

<blockquote><p><a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">ReactiveCocoa 用 RACSignal 替代 Delegate</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodeChip]]></title>
    <link href="http://limon-.github.io//blog/2014/07/28/codechip/"/>
    <updated>2014-07-28T00:10:03+08:00</updated>
    <id>http://limon-.github.io//blog/2014/07/28/codechip</id>
    <content type="html"><![CDATA[<h1>CodeChip</h1>

<h3>改变UITextfiedl的placeholder的颜色</h3>

<pre><code>[searchField setValue:[UIColor whiteColor] forKeyPath:@"_placeholderLabel.textColor"];
</code></pre>

<h3>统计数组中重复对象的个数</h3>

<pre><code>NSArray *array = @[@1, @2, @2, @1];
NSCountedSet *set = [[NSCountedSet alloc]initWithArray:array];

[set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
    NSLog(@"%@ =&gt; %lu", obj, (unsigned long)[set countForObject:obj]);
}];
</code></pre>

<blockquote><p>Each distinct object inserted into an NSCountedSet object has a counter associated with it.</p></blockquote>

<p>即，NSCountedSet内的每个不同的对象都有一个与之相关的计数器。
也就是说如果遇到重复对象的加入，这个对象的计数器就会+1。所以这个类有个名叫<code>- (NSUInteger)countForObject:(id)object;</code>的方法来统计重复对象的个数。</p>

<h3>跳转到系统设置界面(只适用用iOS 8)</h3>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
</code></pre>

<h3>跳转到APP Store（iOS 7之后）</h3>

<p>跳转到产品详情界面</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"itms-apps://itunes.apple.com/app/idxxxxxx"]];
</code></pre>

<p>跳转到产品评论界面</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=xxxxxx&amp;pageNumber=0&amp;sortOrdering=2&amp;type=Purple+Software&amp;mt=8"]];
</code></pre>

<p>xxxxx是的Apple ID</p>

<h3>隐藏键盘(点击屏幕任意位置)</h3>

<p>在VC中添加</p>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    [super touchesBegan:touches withEvent:event];
    [self.view endEditing:YES];
}   
</code></pre>

<h3>解决64位上%d和%u警告</h3>

<pre><code>#if __LP64__
#define NSI "ld"
#define NSU "lu"
#else
#define NSI "d"
#define NSU "u"
#endif 
</code></pre>

<p>使用</p>

<pre><code>NSInteger row = 2;
NSLog(@"i=%"NSI, row);
</code></pre>

<h3>判断一个view是否是另一个view的子视图</h3>

<pre><code>- (BOOL)isDescendantOfView:(UIView *)view;
</code></pre>

<h3>获取点击处的cell的indexPath</h3>

<pre><code>NSIndexPath *path = [_collectionView indexPathForItemAtPoint:[button convertPoint:CGPointZero toView:self.collectionView]];
</code></pre>

<h3>度数转换为弧度</h3>

<pre><code>#define tranformDegree(x) ((x)*(M_PI)/(180.0f))
</code></pre>

<p>弧度 = 角度* π / 180</p>

<h3>判断string是中文</h3>

<pre><code>unichar c = [searchString characterAtIndex:0];
// 汉字
if (c &gt;= 0x4E00 &amp;&amp; c &lt;= 0x9FFF){
}
</code></pre>

<h3>将数组切割成字符串</h3>

<pre><code>NSArray *array=[[NSArray alloc]initWithObjects:@"苹果",@"香蕉",@"草莓", @"菠萝", nil];
NSString *newString=[array componentsJoinedByString:@","];    
NSLog(@"%@", newString);
</code></pre>

<h3>将字符串切割成数组</h3>

<pre><code>NSString *a = [[NSString alloc] initWithString : @"冬瓜，西瓜，火龙果，大头，小狗" ];
NSArray *b = [a componentsSeparatedByString:@"，"];
</code></pre>

<h2>TableView</h2>

<h3>在包含UITableView视图中添加单击手势</h3>

<p>如果在包含UITableView视图中添加单击手势，这个单击手势会屏蔽掉UITableView的<code>didSelectRowAtIndexPath</code>
在单击点位于UITableView内的时候取消响应</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
    CGPoint point = [gestureRecognizer locationInView:self];
    if(CGRectContainsPoint(menuTableView.frame, point)){
        return NO;
    }
    return YES;
}
</code></pre>

<p>简单点的就将单击手势的cancelsTouchesInView设置为NO即可</p>

<pre><code>singleTap.cancelsTouchesInView = NO;
</code></pre>

<blockquote><p>默认为YES，若NO，Gesture Recognizers和hit-test view同时响应触摸序列</p></blockquote>

<h3>修改cell右边图标颜色</h3>

<pre><code>mytableView.tintColor = [UIColor greenColor];
</code></pre>

<h3>cell删除动画</h3>

<pre><code>//删除一个cell时，设定动画模式
[tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];
</code></pre>

<h2>杂</h2>

<p>计算字符串宽度</p>

<pre><code>CGFloat priceLabelW = [priceStr sizeWithAttributes:@{NSFontAttributeName:searchResultsNameFont}].width;
</code></pre>

<p>json编码</p>

<pre><code>NSString *jsonString = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa的三种基本的模式]]></title>
    <link href="http://limon-.github.io//blog/2014/06/10/reactivecocoa/"/>
    <updated>2014-06-10T09:35:03+08:00</updated>
    <id>http://limon-.github.io//blog/2014/06/10/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<hr />

<h3>三种基本的模式</h3>

<p>在ReactiveCocoa中有三种基本的模式：责任链、分割和组合模式（chaining, splitting, and combining）。</p>

<h4>一、 Chaining模式</h4>

<p>Chaining，将一个已有的signal转换为一个新的signal。常用的操作是创建一个新的signal，再对它使用filter:、map:或startWith:等方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.textField.text) = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}]; 
</span></code></pre></td></tr></table></div></figure>


<p>我们将textFiled的text属性绑定为三个串连的signals的结果。首先，我们创建一个间隔信号，这个信号每隔一秒钟就发送当前时间。间隔信号在没有启动的时候是不会有值的，所以我们使用startWith:启动起来。最后，使用map:将signal的NSDate值转换为一个NSString字符串，这个字符串将会被赋值到textField的text属性上。
<img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/chaining.png" alt="Chaining" /></p>

<p> Chaining是最常用的操作，而且它通常不使用局部变量，而是像上面那样串连起来操作。下面的代码与上面的代码是等同的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *intervalSignal = [RACSignal interval:1];  
</span><span class='line'>RACSignal *startedIntervalSignal = [intervalSignal startWith:[NSDate date]];  
</span><span class='line'>RACSignal *mappedIntervalSignal = [startedIntervalSignal map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.textField.text) = mappedIntervalSignal;  </span></code></pre></td></tr></table></div></figure>


<h4>二、Splitting模式</h4>

<p>Splitting与chaining比较类似，也是将signal转换为其它的sginal，不同之处在于，Splitting会重复使用signal。Splitting看起来要复杂些，其实也就是一个signal使用多次。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *dateComponentsSignal = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>    return dateComponents;  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.minuteTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.minute];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.secondTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.second];  
</span><span class='line'>}];  </span></code></pre></td></tr></table></div></figure>


<p>在上面这个例子中，创建了一个signal，即局部变量：dateComponentsSignal。接着再用dateComponentsSignal创建两个新的signal，并将它们分别与两个textfield的text属性进行绑定。</p>

<blockquote><p>Note: 把dateComponentsSignal看作一个局部变量，就像,int a = 9; 然后多次使用a来计算。</p></blockquote>

<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/Splitting.png" alt="Splitting" /></p>

<h4>三、Combining模式</h4>

<p>combining就是将几个signal结合起来创建出一个新的signal。比如“登录”按钮，只有在“用户名”与“密码”输入框中的文本长度都超过6时才能被点击，否则处于不可用的状态。那么我们可以为“登录”按钮的enabled状态创建一个signal，这个signal则是由“用户名”与“密码”框它们两个自己的signal组合起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.submitButton.enabled) = [RACSignal combineLatest:@[self.usernameField.rac_textSignal, self.passwordField.rac_textSignal] reduce:^id(NSString *userName, NSString *password) {  
</span><span class='line'>    return @(userName.length &gt;= 6 && password.length &gt;= 6);  
</span><span class='line'>}]; </span></code></pre></td></tr></table></div></figure>


<p>在这里，我们将“登录”按钮的enable状态绑定到使用combineLatest:reduce:方法创建的signal上。这个方法的第二个参数是一个block，这个block的参数是combineLatest中的参数的<strong>最新值</strong>的组合。我们将两个文本框的text signal一起传到combineLatest，在reduce的block中，该block也就会接收到两个NSString的参数，这个block的工作就是将两个参数值组合起来生成一个值，然后返回。该方法的说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// +combineLatest:reduce: takes an array of signals, executes the block with the
</span><span class='line'>// latest value from each signal whenever any of them changes, and returns a new
</span><span class='line'>// RACSignal that sends the return value of that block as values.</span></code></pre></td></tr></table></div></figure>


<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/combining.png" alt="Combining" /></p>

<p>Combining常用于两种情况：</p>

<ol>
<li>需要同时满足多种条件。</li>
<li>在多个signal中进行选择。</li>
</ol>


<h2>优秀文章</h2>

<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/">Getting Started with ReactiveCocoa</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#01-字面量语法]]></title>
    <link href="http://limon-.github.io//blog/2014/05/26/number-01-zi-mian-liang-yu-fa/"/>
    <updated>2014-05-26T12:40:19+08:00</updated>
    <id>http://limon-.github.io//blog/2014/05/26/number-01-zi-mian-liang-yu-fa</id>
    <content type="html"><![CDATA[<h2>字面量数值</h2>

<p>普通创建：</p>

<pre><code>NSNumber *num = [NSNumber numberWithInt:1];
</code></pre>

<p>字面量创建</p>

<pre><code>NSNumber *nub = @1;

int a = 5;
float b = 5.32f;
NSNumber *num = @(a * b);
</code></pre>

<h2>字面量数组</h2>

<p>普通创建</p>

<pre><code>NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",@"Apple",nil];
[fruits objectAtIndex:1]; // Apple
</code></pre>

<p>字面量创建</p>

<pre><code>NSArray *fruits = @[@"Lemon",@"Apple"];
fruits[1]; // Apple
</code></pre>

<p><code>fruits[1]</code>这称为取下标操作(subscripting)</p>

<h2>nil</h2>

<p>字面量创建数组，若数组元素对象中有nil，会抛出异常。因为字面量语法实际上是一种语法糖(syntactic sugar)，其效果等于是先创建了一个数组，然后把方括号内的所有对象都加到这个数组。</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = @[@"Lemon",nilObject,@"Apple"]; // 崩了
</code></pre>

<p>如果不用字面量创建，用<code>NSArray arrayWithObjects:</code>则不会抛出异常，只会提前结束。如下例子，遇到nil结束，fruits只有一个元素</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",nilObject,@"Apple",nil];
</code></pre>

<blockquote><p>微妙的差别表明，使用字面量语法更安全。向数组插入nil通常说明程序有错，而通过异常可以更快地发现这个错误。</p></blockquote>

<h2>字面量字典</h2>

<p>值 -> 键：普通创建</p>

<pre><code>NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:@"Tom",@"name",[NSNumber numberWithInt:18],@"age", nil];
[personData objectForKey:@"name"]; // Tom
</code></pre>

<p>键 -> 值：字面量语法创建</p>

<pre><code>NSDictionary *personData = @{@"name": @"Tom",@"age":@18};
personData[@"age"]; // 18
</code></pre>

<h2>可变数组和字典</h2>

<p>如果数组与字典对象是可变的(mutable)，也可以通过下标修改可变数组或字典的值</p>

<pre><code>mutableArray[1] = @"dog";
mutableDictionary[@"name"] = @"Mary";
</code></pre>

<p>普通做法：</p>

<pre><code>[mutableArray replaceObjectAtIndex:1 withObject:@"dog"];
[mutableDic setObject:@"Mary" forKey:@"name"];
</code></pre>

<h2>局限</h2>

<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable),若想可变版本的对象，则需要赋值一份</p>

<pre><code>NSMutableDictionary *mutableDic = [@{@"name": @"Tom",@"age":@18} mutableCopy];
</code></pre>

<h2>要点</h2>

<ul>
<li>应该使用字面量语法创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，更加简明扼要。</li>
<li>应该通过下标来访问数组和字典</li>
<li>用字面量语法创建数组或字典时，若值中有nil，会抛出异常。</li>
</ul>


<h2>番外</h2>

<p>JSON格式，一对 <code>{ }</code> 代表一个字典，一对<code>[]</code>代表一个数组</p>

<pre><code>{
    "result": 1,

    "school_list": [
        {
            "id": "5",
            "school_name": "清华大学"             
        },
        {
            "id": "6",
            "school_name": "北京邮电大学"
        }
    ],

    "school_near": "北京交通大学"
}
</code></pre>

<p>从JSON<strong>字典</strong>中通过键<code>school_list</code>取出数组对象</p>

<pre><code>NSArray *arr = json[@"school_list"];
NSArray *arr = [json objectForKey:@"school_list"];
</code></pre>

<p>arr数组的元素是一个个字典，遍历数组得到字典内的学校名</p>

<pre><code>for( int i=0; i&lt;arr.count; i++){
        NSString *schoolName = arr[i][@"school_name"];
        NSString *schoolName = [[arr objectAtIndex:i] objectForKey:@"school_name"];
    }
</code></pre>

<p>其实arr数组就是PHP内的二维数组，只不过在OS中，</p>

<ul>
<li>数组 - 下标为数字（PHP中的索引数组）</li>
<li>字典 - 下标为字符串（PHP中的关联数组）</li>
</ul>


<p>上面例子中二维数组arr的遍历，通过数字下标遍历二维数组中的所有元素，然后通过字符串下标取出学校名。</p>

<blockquote><p>下标也称为键</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转Mantle]]></title>
    <link href="http://limon-.github.io//blog/2014/04/23/mantlede-shi-yong/"/>
    <updated>2014-04-23T10:05:15+08:00</updated>
    <id>http://limon-.github.io//blog/2014/04/23/mantlede-shi-yong</id>
    <content type="html"><![CDATA[<h2>MTLModel</h2>

<p>MTLModel provides an easy way to map NSDictionary objects to Objective-C classes and vice-versa.</p>

<p>假设返回的JSON为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> {
</span><span class='line'>  "uid": 1,
</span><span class='line'>  "title": "Found a bug",
</span><span class='line'>  "url": "https://api.github.com/repos/octocat/Hello-World/issues/1347",
</span><span class='line'>  "number": 1347,
</span><span class='line'>  "state": "open",
</span><span class='line'>  "user": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1
</span><span class='line'>  },
</span><span class='line'>  "assignee": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1,
</span><span class='line'>    "type": "User"
</span><span class='line'>  }
</span><span class='line'>  "created_at": "2011-04-22T13:33:48Z",
</span><span class='line'>  "awesome": true  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>继承<code>MTLModel</code>遵守<code>&lt;MTLJSONSerializing&gt;</code>协议</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Mantle.h&gt;
</span><span class='line'>
</span><span class='line'>typedef enum : NSUInteger {
</span><span class='line'>    GHIssueStateOpen,
</span><span class='line'>    GHIssueStateClosed
</span><span class='line'>} GHIssueState;
</span><span class='line'>
</span><span class='line'>@interface GHIssue : MTLModel&lt;MTLJSONSerializing&gt;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *uid;
</span><span class='line'>@property (nonatomic, copy, readonly) NSURL *URL;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *number;
</span><span class='line'>@property (nonatomic, assign, readonly) GHIssueState state;
</span><span class='line'>@property (nonatomic, copy, readonly) NSString *reporterLogin;
</span><span class='line'>@property (nonatomic, copy, readonly) NSDate *updatedAt;
</span><span class='line'>@property (nonatomic, strong, readonly) GHUser *assignee;
</span><span class='line'>@property(nonatomic, getter=isAwesome) BOOL awesome;
</span><span class='line'>@property (nonatomic, copy) NSString *title;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p><code>&lt;MTLJSONSerializing&gt;</code>协议告诉Mantle序列化该对象如何从JSON映射到Objective-C的属性。</p>

<h3>NSValueTransformer</h3>

<p>在.m文件，实现<code>&lt;MTLJSONSerializing&gt;</code>的协议<code>@required</code>的方法<code>+ (NSDictionary *)JSONKeyPathsByPropertyKey</code>
它指明了如何把json的keypath和Model的属性对应起来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSDictionary *)JSONKeyPathsByPropertyKey {
</span><span class='line'>  // properties defined in header  :  key in JSON Dictionary，本地字段在前，服务端字段在后
</span><span class='line'>    return @{
</span><span class='line'>        @"URL": @"url",
</span><span class='line'>        @"HTMLURL": @"html_url",
</span><span class='line'>        @"reporterLogin": @"user.login",
</span><span class='line'>        @"assignee": @"assignee",
</span><span class='line'>        @"updatedAt": @"updated_at"
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为如果属性名和JSON的键名一致时，可以省略不写映射，例如title</p>

<p>以上分了几种情况：
Mantle使用主要看属性property中的类型，主要分几种：</p>

<ol>
<li>NSNumber、NSString&hellip;.</li>
<li>NSArray</li>
<li>NSURL</li>
<li>NSDate</li>
<li>枚举</li>
<li>模型</li>
<li>BOOL</li>
</ol>


<p>先介绍一个方法：<code>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Specifies how to convert a JSON value to the given property key. If
</span><span class='line'>// reversible, the transformer will also be used to convert the property value
</span><span class='line'>// back to JSON.
</span><span class='line'>//
</span><span class='line'>// If the receiver implements a `+&lt;key&gt;JSONTransformer` method, MTLJSONAdapter
</span><span class='line'>// will use the result of that method instead.
</span><span class='line'>//
</span><span class='line'>// Returns a value transformer, or nil if no transformation should be performed.
</span><span class='line'>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;
</span></code></pre></td></tr></table></div></figure>


<p>以下方法的命名都要遵从：<code>SEL selector = MTLSelectorWithKeyPattern(key, "JSONTransformer");</code></p>

<p>1、一般像tittle，<code>@"title": @"title"</code>不用写这行也自动转化。我个人认为从服务器返回的所有数据都是字符串类型。所有理论上，uid还要用<code>NSValueTransformer</code>转化，如下：</p>

<pre><code>+ (NSValueTransformer *)uidJSONTransformer{
    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^id(NSString *string) {
    return @([string integerValue]);
} reverseBlock:^id(NSNumber *number) {
    return [number stringValue];
}];
</code></pre>

<p>}</p>

<p>但是，如果你的uid属性类型定义为NSNumber，还是不需用上面的方法，应该是Mantle自己处理了。</p>

<blockquote><p>如果你定义的uid类型为NSUInteger，还是需要uidJSONTransformer</p></blockquote>

<p>还有一种情况是<code>@"reporterLogin": @"user.login"</code>
   login是在JSON内层的元素，需要用下面这个方法</p>

<pre><code class="```">   + (NSValueTransformer *)reporterLoginJSONTransformer {
        return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSArray *values) {
            return [values firstObject];
        } reverseBlock:^(NSString *str) {
            return @[str];
        }];
    }
</code></pre>

<p>2、NSArray装模型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  name: "Bob",
</span><span class='line'>  cars: [
</span><span class='line'>    { make: "ford", year: "1972" },
</span><span class='line'>    { make: "mazda", year: "2000" }
</span><span class='line'>  ],
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface CarModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *make;
</span><span class='line'>@property (nonatomic, strong) NSString *year;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@interface PersonModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *name;
</span><span class='line'>@property (nonatomic, strong) NSArray *cars; // NSArra元素是Car模型
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)carsJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CarModel.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3、NSURL</p>

<pre><code>+ (NSValueTransformer *)URLJSONTransformer {
    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
}           
</code></pre>

<p>4、NSDate</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>+ (NSDateFormatter *)dateFormatter {
</span><span class='line'>    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
</span><span class='line'>    dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
</span><span class='line'>    dateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss'Z'";
</span><span class='line'>    return dateFormatter;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (NSValueTransformer *)updatedAtJSONTransformer { // 把"updated_at": "2011-04-22T13:33:48Z"传给ForwardBlock
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [self.dateFormatter dateFromString:str]; // 把dateFormatter再传给reverseBlock
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [self.dateFormatter stringFromDate:date];
</span><span class='line'>    }]
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果JSON的数据格式是Unix时间戳，&#8221;date&#8221;: 1418202490,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)dateJSONTransformer {
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [NSDate dateWithTimeIntervalSince1970:str.floatValue];
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [NSString stringWithFormat:@"%f",[date timeIntervalSince1970]];
</span><span class='line'>    }];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>5、枚举</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)stateJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{
</span><span class='line'>        @"open": @(GHIssueStateOpen),
</span><span class='line'>        @"closed": @(GHIssueStateClosed)
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>6、模型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)assigneeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONDictionaryTransformerWithModelClass:GHUser.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>7、 BOOL</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)awesomeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>空对象处理</h2>

<p>在模型.m文件添加<code>-setNilValueForKey</code>，Mantle是基于KVC给property赋值的，KVC提供了<code>-setNilValueForKey</code>方法，让我们为nil指定一个合理的替代值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface MTLModel (KTVNullableScalar)
</span><span class='line'>@end
</span><span class='line'>@implementation MTLModel (KTVNullableScalar)
</span><span class='line'>- (void)setNilValueForKey:(NSString *)key {
</span><span class='line'>    [self setValue:@0 forKey:key];  // For NSInteger/CGFloat/BOOL
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>Create model objects from JSON</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from JSON data
</span><span class='line'>NSData JSONData = ... // the JSON response from the API
</span><span class='line'>NSError *error = nil;
</span><span class='line'>NSDictionary *JSONDict = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:&error];
</span><span class='line'>
</span><span class='line'>// create model object from NSDictionary using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = [MTLJSONAdapter modelOfClass:CATProfile.class fromJSONDictionary:JSONDict error:NULL];</span></code></pre></td></tr></table></div></figure>


<h2>Create JSON from model objects</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from model class using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = ...
</span><span class='line'>NSDictionary *profileDict = [MTLJSONAdapter JSONDictionaryFromModel:profile];
</span><span class='line'>NSError *error = nil;
</span><span class='line'>// convert NSDictionary to JSON data
</span><span class='line'>NSData *JSONData = [NSJSONSerialization dataWithJSONObject:profileDict options:0 error:&error];</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Note：如果不想JSONData含有模型的某个属性，可以在模型JSONKeyPathsByPropertyKey方法中
    return @{ @&ldquo;Name&rdquo;: NSNull.null };</p></blockquote>

<h2>Serialize 序列化</h2>

<p>待续&hellip;</p>

<h2>优秀文章</h2>

<p><a href="http://spin.atomicobject.com/2014/06/23/ios-models-mantle/">Simplify iOS Models With Mantle – An Intro</a></p>

<p><a href="http://www.objc.at/mantle">mantle</a></p>

<p><a href="http://www.cnblogs.com/ipinka/p/4041835.html">iOS的Mantle实战</a></p>

<p><a href="http://ke.gitcafe.io/2014/10/13/Why-Changba-iOS-choose-Mantle/">为什么唱吧iOS 6.0选择了Mantle</a></p>
]]></content>
  </entry>
  
</feed>
